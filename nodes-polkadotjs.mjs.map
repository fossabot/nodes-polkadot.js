{"version":3,"sources":["_init.js","NodeToast.js","Connection/Extension.js","generator.js","Account/Transfer.js","Connection/HTTP.js","Connection/WebSocket.js","Constant/generator.js","Convert/Mnemonic.js","Data/Sign.js","Data/Verify.js","Events/Blocks.js","Extrinsics/generator.js","Keyring/Dummy.js","Storage/generator.js","Transaction/DryRun.js","Transaction/PaymentInfo.js","Transaction/Send.js","Convert/Address To/Address.js","Convert/Address To/Uint8Array.js","Convert/String To/Uint8Array.js","Convert/Uint8Array To/String.js","Data/Keyring/Decrypt.js","Data/Keyring/Encrypt.js","Events/Account/Balance.js","Extension/Get/Signer.js","Keyring/Create/Keypair.js","Keyring/Create/Keyring.js","Keyring/Create/Mnemonic.js","Keyring/Create/Seed.js"],"names":["window","module","_class","_temp","_class2","_temp2","_class3","_temp3","_class4","_temp4","_class5","_temp5","_class6","_temp6","_class7","_temp7","_class8","_temp8","_class9","_temp9","_class10","_temp10","_class11","_temp11","_class12","_temp12","_class13","_temp13","_class14","_temp14","_class15","_temp15","_class16","_temp16","_class17","_temp17","_class18","_temp18","_class19","_temp19","_class20","_temp20","_class21","_temp21","_class22","_temp22","_class23","_temp23","_class24","_temp24","exports","globalThis","Object","defineProperty","value","polkadotApi","polkadotKeyring","polkadotTypes","polkadotUtilCrypto","polkadotUtil","Blackprint","loadScope","url","import","meta","hasInterface","crypto","Environment","isNode","webcrypto","_remoteModule","isDeno","i","length","push","sf","loader","js","ordered","Context","createContext","EventSlot","slot","internalKeyring","Keyring","type","ss58Format","Transaction","constructor","txn","this","Signer","isPair","address","signer","utils","renameTypeName","ApiPromise","WsProvider","HttpProvider","_extensionEnabled","NodeToast","iface","clear","haveInfo","destroy","haveWarn","haveError","_reduceText","text","replace","full","slice","info","$decoration","temp","_raw","warn","error","success","SubstrateSubscriber","SubmitAndWatchExtrinsic","Subscribe","SubscribeAllHeads","SubscribeFinalizedHeads","SubscribeJustifications","SubscribeNewHeads","SubscribeRuntimeVersion","SubscribeStorage","SubstrateTypeData","AccountId","String","ApplyExtrinsicResult","BeefySignedCommitment","BlockHash","BlockNumber","Number","Bytes","ChainProperties","ChainType","ContractCallRequest","ContractExecResult","ContractInstantiateResult","CreatedBlock","EthAccount","EthCallRequest","EthFilter","EthFilterChanges","EthReceipt","EthRichBlock","EthSubKind","EthSubParams","EthSyncStatus","EthTransaction","EthTransactionRequest","EthWork","Extrinsic","ExtrinsicStatus","FeeDetails","H64","H160","H256","Hash","Header","Health","Index","InstantiateRequest","Json","Justification","JustificationNotification","Metadata","MmrLeafProof","NetworkState","Null","PrefixedStorageKey","ReadProof","ReportedRoundStates","RpcMethods","RuntimeDispatchInfo","RuntimeVersion","SignedBlock","StorageChangeSet","StorageData","StorageKey","StorageKind","SyncState","Text","TraceBlockResponse","U64","U256","bool","Boolean","u32","u64","functionParser","str","options","list","trim","split","funcName","args","returnType","isConst","console","argsName","typeAsName","join","e","name","argsObj","a","toUpperCase","Substrate_BlackprintNodeGenerator","namespace","description","apiPath","funcs","that","func","test","loose","returnToField","preprocessType","portName","wrapper","RPCParams","keys","typeData","category","A","B","apiName","toLowerCase","defaultInput","API","Trigger","Port","trigger","GeneratedNode","Node","instance","super","setInterface","title","_toast","update","Input","Output","ref","rpc_path","async","toast","obj","response","apply","message","output","input","assign","registerNode","imported","IInput","IOutput","onChanged","Address","Value","tx","balances","transfer","Txn","on","port","source","extensionEnabled","Promise","resolve","ConnectionExtensionData","_dAppName","_iface","dAppName","val","data","undefined","Accounts","Array","IsAllowed","registerInterface","IFace","ConnectionExtension","Interface","node","polkadot","injectedWeb3","_polkadot","polkadotExtensionDapp","web3Enable","web3Accounts","_unsubscribe","web3AccountsSubscribe","accounts","ConnectionHTTPData","_rpcURL","rpcURL","changeRPC","http","Provider","disconnect","Disconnected","Reconnect","Connected","Function","ConnectionHTTP","provider","api","create","throwOnConnect","isConnected","ConnectionWebSocketData","ws","Connect","connect","Disconnect","ConnectionWebSocket","init","Seed","mnemonicToMiniSecret","mnemonicValidate","Uint8Array","_fail","msg","Data","stringToU8a","sign","u8aToHex","stringToHex","signRaw","hexToU8a","signature","Union","IsValid","Signature","cryptoWaitReady","signatureVerify","isValid","unsubscribe","hasSubscriptions","rpc","chain","subscribeNewHeads","header","number","toNumber","EventsBlocks","randomAsU8a","keyring","KeyType","pair","Pair","addFromSeed","Default","onStatus","ev","Status","dryRun","log","paymentInfo","Info","submit","isSubmit","signAndSend","Submit","ChainId","encodeAddress","decodeAddress","In","Out","u8aToString","CrypterNode","Keypair","keypair","Author","author","decrypted","decryptMessage","Target","target","encrypt","encryptMessage","EventsAccountBalance","query","system","account","web3FromAddress","oldKeyring","_keyring","removePair","Mnemonic","disconnectAll","addFromMnemonic","byteLength","currentKeyType","keyType","mnemonicGenerate"],"mappings":"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","file":"nodes-polkadotjs.mjs","sourcesContent":["// Let the Blackprint Editor know the source URL where\n// the registerNode and registerInterface belongs to\nvar Blackprint = window.Blackprint.loadScope({\n\t// You can find the URL on Blackprint menu -> Modules\n\t// This will also be exported to JSON if this module's nodes is being used\n\turl: import.meta.url,\n\n\t// This will autoload (*.sf.mjs) and (*.sf.css) file for Browser\n\thasInterface: true,\n});\n\n\n// Prepare variable\nvar polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil;\n\n\n// Import for different environment\nlet crypto = window.crypto;\nif(window.Blackprint.Environment.isNode) {\n\tcrypto = (await import('crypto')).webcrypto;\n\n\t// Use the bundled version\n\tawait import('../node_modules/@polkadot/util/bundle-polkadot-util.js');\n\tawait import('../node_modules/@polkadot/util-crypto/bundle-polkadot-util-crypto.js');\n\tawait import('../node_modules/@polkadot/keyring/bundle-polkadot-keyring.js');\n\tawait import('../node_modules/@polkadot/types/bundle-polkadot-types.js');\n\tawait import('../node_modules/@polkadot/api/bundle-polkadot-api.js');\n\n\t({ polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil } = window);\n}\nelse{\n\t/* Parallely load dependencies from CDN */\n\t// Use bundled file\n\t// This will be registered on global (window)\n\tlet _remoteModule = [\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/util@8.3.3/bundle-polkadot-util.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/util-crypto@8.3.3/bundle-polkadot-util-crypto.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/keyring@8.3.3/bundle-polkadot-keyring.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/types@7.6.1/bundle-polkadot-types.js\",\n\t\t\"https://cdn.jsdelivr.net/npm/@polkadot/api@7.6.1/bundle-polkadot-api.js\",\n\t];\n\n\tif(window.Blackprint.Environment.isDeno) { // Untested\n\t\tfor (var i = 0; i < _remoteModule.length; i++)\n\t\t\tawait import(_remoteModule[i]);\n\t}\n\telse { // For Browser environment\n\t\t_remoteModule.push(\"https://cdn.jsdelivr.net/npm/@polkadot/extension-dapp@0.42.7/bundle-polkadot-extension-dapp.js\");\n\t\tawait sf.loader.js(_remoteModule, {ordered: true});\n\t}\n\n\t({ polkadotApi, polkadotKeyring, polkadotTypes, polkadotUtilCrypto, polkadotUtil } = window);\n\t// polkadotExtensionDapp library is not using UMD\n}\n\n\n// Global shared context\nvar Context = Blackprint.createContext('Polkadot.js');\n\n// This is needed to avoid duplicated event listener when using hot reload\n// Event listener that registered with same slot will be replaced\nContext.EventSlot = {slot: 'my-private-event-slot'};\n\n// internal Keyring that will be used by some node if not connected to any keyring\nvar internalKeyring = new polkadotApi.Keyring({\n\ttype: 'ed25519',\n\tss58Format: 0,\n});\n\n// Custom class: for Port's type check\nclass Transaction {\n\tconstructor(txn){this.txn = txn}\n}\n\nclass Signer {\n\tconstructor(isPair, address, signer){\n\t\tthis.isPair = isPair;\n\t\tthis.address = address;\n\t\tthis.signer = signer;\n\t}\n}\n\n\n// Fix minified class name\nBlackprint.utils.renameTypeName({\n\t'Transaction': Transaction,\n\t'Signer': Signer,\n\t'ApiPromise': polkadotApi.ApiPromise,\n\t'Keyring': polkadotApi.Keyring,\n\t'WsProvider': polkadotApi.WsProvider,\n\t'HttpProvider': polkadotApi.HttpProvider,\n});","/**\n * import { Context } from \"./_init.js\";\n */\n\n// Bootstrap for add toast on node decoration\nlet NodeToast = Context.NodeToast = class NodeToast {\n\tconstructor(iface){\n\t\tthis.iface = iface;\n\t}\n\n\tclear(){\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.destroy();\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.destroy();\n\t\tif(this.haveError)\n\t\t\tthis.haveError.destroy();\n\n\t\tthis.haveInfo = false;\n\t\tthis.haveWarn = false;\n\t\tthis.haveError = false;\n\t}\n\n\t_reduceText(text){\n\t\treturn text.replace(/\\w{15,}/g, full => full.slice(0, 5)+'...');\n\t}\n\n\tinfo(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveInfo)\n\t\t\tthis.haveInfo.text = text;\n\t\telse\n\t\t\tthis.haveInfo = this.iface.$decoration.info(text);\n\n\t\tthis.haveInfo._raw = temp;\n\t}\n\n\twarn(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveWarn)\n\t\t\tthis.haveWarn.text = text;\n\t\telse\n\t\t\tthis.haveWarn = this.iface.$decoration.warn(text);\n\n\t\tthis.haveWarn._raw = temp;\n\t}\n\n\terror(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet temp = text;\n\t\ttext = this._reduceText(text);\n\n\t\tif(this.haveError)\n\t\t\tthis.haveError.text = text;\n\t\telse\n\t\t\tthis.haveError = this.iface.$decoration.error(text);\n\n\t\tthis.haveError._raw = temp;\n\t}\n\n\tsuccess(text){\n\t\tif(!this.iface.$decoration) return;\n\t\tlet ref = this.iface.$decoration.success(this._reduceText(text));\n\t\tref._raw = text;\n\t}\n}","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotExtensionDapp, polkadotApi } = window\n */\n\nlet _extensionEnabled;\nlet extensionEnabled = new Promise(resolve=> _extensionEnabled = resolve);\n\n\n// For storing node data\nclass ConnectionExtensionData {\n\tconstructor(iface){this._iface = iface}\n\n\t_dAppName = 'BP-Polkadot.js';\n\tget dAppName(){return this._dAppName}\n\tset dAppName(val){this._dAppName = val}\n}\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Connection/Extension\",\nclass ExtensionNode extends Blackprint.Node {\n\tstatic input = undefined; // This node doesn't need any input port\n\tstatic output = {\n\t\tAccounts: Array,\n\t\tIsAllowed: Boolean,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./Extension.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/Extension');\n\t\tiface.title = \"Browser Wallet\";\n\t\tiface.description = \"Connect to extension\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded, but no cable connected\n\timported(data){\n\t\tif(!data) return;\n\t\tObject.assign(this.iface.data, data);\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/Extension',\nContext.IFace.ConnectionExtension = class ExtensionIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\n\t\tthis.data = new ConnectionExtensionData(this);\n\t}\n\n\t// This will be called by the engine after node has been loaded\n\t// and other data like cable connection has been connected/added\n\tasync init(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\n\t\tlet polkadot = window.injectedWeb3?.[\"polkadot-js\"];\n\t\tif(polkadot === void 0)\n\t\t\treturn this._toast.error(\"Extension injection was not found\");\n\n\t\tthis._toast.clear();\n\t\tthis._toast.warn(\"Asking for Permission\");\n\n\t\ttry{\n\t\t\tthis._polkadot = await polkadotExtensionDapp.web3Enable(this.data.dAppName);\n\t\t} catch(e) {\n\t\t\tOutput.IsAllowed = false;\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.warn(\"Access Rejected\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis._toast.clear();\n\t\tthis._toast.success(\"Access Granted\");\n\t\tOutput.IsAllowed = true;\n\n\t\t_extensionEnabled();\n\t\textensionEnabled = true;\n\n\t\tthis.node.output.Accounts = await polkadotExtensionDapp.web3Accounts();\n\n\t\tlet node = this;\n\t\tthis._unsubscribe = await polkadotExtensionDapp.web3AccountsSubscribe(accounts => {\n\t\t\tthis.node.output.Accounts = accounts;\n\t\t});\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\t// Unsubscribe to event listener if exist\n\t\ttry{\n\t\t\tthis._unsubscribe?.();\n\t\t} catch(e) {\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n\n\t// ToDo: Implement this if in the future the wallet has an RPC\n\tasync _connect(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet polkadot = this._polkadot;\n\n\t\t// let provider = Output.Socket = new ExtensionProvider(polkadot.provider);\n\n\t\tlet that = this;\n\t\tthat._toast.clear();\n\t\t// this._toast.warn(\"Connecting...\");\n\n\t\t// provider.on('connected', function(){\n\t\t// \tthat._toast.clear();\n\t\t// \tthat._toast.success(\"Connected\");\n\t\t// \tOutput.Connected();\n\t\t// });\n\n\t\t// provider.on('disconnected', function(){\n\t\t// \tthat._toast.warn(\"Disconnected\");\n\t\t// \tOutput.Disconnected();\n\t\t// });\n\n\t\t// Output.API = await polkadotApi.ApiPromise.create({ provider });\n\t}\n});","// Work in progress and untested nodes\n// Please expect changes on the port's name and type data on the future\n\n// Set this to true to enable this generator\nlet SubstrateMetadata = true;\n\n// Watch/Subscribe will be an event\nlet SubstrateSubscriber = {\n\tSubmitAndWatchExtrinsic: \"author\",\n\tSubscribe: \"eth\",\n\tSubscribeAllHeads: \"chain\",\n\tSubscribeFinalizedHeads: \"chain\",\n\tSubscribeJustifications: \"grandpa\",\n\tSubscribeNewHeads: \"chain\",\n\tSubscribeRuntimeVersion: \"state\",\n\tSubscribeStorage: \"state\",\n};\n\n// ToDo: Type mapping (Rust Types => JavaScript Types)\nlet SubstrateTypeData = {\n\t'AccountId': String,\n\t'ApplyExtrinsicResult': null,\n\t'BeefySignedCommitment': null,\n\t'BlockHash': null,\n\t'BlockNumber': Number,\n\t'Bytes': String,\n\t'ChainProperties': null,\n\t'ChainType': null,\n\t'ContractCallRequest': null,\n\t'ContractExecResult': null,\n\t'ContractInstantiateResult': null,\n\t'CreatedBlock': null,\n\t'EthAccount': null,\n\t'EthCallRequest': null,\n\t'EthFilter': null,\n\t'EthFilterChanges': null,\n\t'EthReceipt': null,\n\t'EthRichBlock': null,\n\t'EthSubKind': null,\n\t'EthSubParams': null,\n\t'EthSyncStatus': null,\n\t'EthTransaction': null,\n\t'EthTransactionRequest': null,\n\t'EthWork': null,\n\t'Extrinsic': null,\n\t'ExtrinsicStatus': null,\n\t'FeeDetails': null,\n\t'H64': String,\n\t'H160': String,\n\t'H256': String,\n\t'Hash': String,\n\t'HashMap<AuthorityId,EpochAuthorship>': null, // ToDo: HashMap<A, B> => {A, B}\n\t'Header': null,\n\t'Health': null,\n\t'Index': null,\n\t'InstantiateRequest': null,\n\t'Json': null,\n\t'Justification': null,\n\t'JustificationNotification': null,\n\t'Metadata': null,\n\t'MmrLeafProof': null,\n\t'NetworkState': null,\n\t'Null': null,\n\t'Option<BlockNumber>': null, // ToDo: Option<A> => A\n\t'Option<Bytes>': null,\n\t'Option<EncodedFinalityProofs>': null,\n\t'Option<EthRichBlock>': null,\n\t'Option<Hash>': null,\n\t'Option<StorageData>': null,\n\t'Option<Text>': null,\n\t'Option<u64>': null,\n\t'PrefixedStorageKey': null,\n\t'ReadProof': null,\n\t'ReportedRoundStates': null,\n\t'RpcMethods': null,\n\t'RuntimeDispatchInfo': null,\n\t'RuntimeVersion': null,\n\t'SignedBlock': null,\n\t'StorageChangeSet': null,\n\t'StorageData': null,\n\t'StorageKey': null,\n\t'StorageKind': null,\n\t'String': null,\n\t'SyncState': null,\n\t'Text': String,\n\t'TraceBlockResponse': null,\n\t'U64': Number,\n\t'U256': Number,\n\t'Vec<EthLog>': null, // ToDo: Vec<A> => [A]\n\t'Vec<Extrinsic>': null,\n\t'Vec<ExtrinsicOrHash>': null,\n\t'Vec<H160>': null,\n\t'Vec<H256>': null,\n\t'Vec<Hash>': null,\n\t'Vec<KeyValue>': null,\n\t'Vec<NodeRole>': null,\n\t'Vec<Option<StorageData>>': null, // ToDo: ?.. maybe [StorageData]\n\t'Vec<PeerInfo>': null,\n\t'Vec<StorageChangeSet>': null,\n\t'Vec<StorageKey>': null,\n\t'Vec<Text>': null,\n\t'bool': Boolean,\n\t'u32': Number,\n\t'u64': Number,\n};\n\n// https://polkadot.js.org/docs/substrate/rpc\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'RPC',\n\tdescription: '[Experimental] Substrate JSON-RPC',\n\tapiPath: 'rpc'\n}, [\n\t{\n\t\tname: \"Author\", rpc_path: \"author\",\n\t\tfuncs: `\n\t\t\thasKey(publicKey: Bytes, keyType: Text): bool\n\t\t\thasSessionKeys(sessionKeys: Bytes): bool\n\t\t\tinsertKey(keyType: Text, suri: Text, publicKey: Bytes): Bytes\n\t\t\tpendingExtrinsics(): Vec<Extrinsic>\n\t\t\tremoveExtrinsic(bytesOrHash: Vec<ExtrinsicOrHash>): Vec<Hash>\n\t\t\trotateKeys(): Bytes\n\t\t\tsubmitAndWatchExtrinsic(extrinsic: Extrinsic): ExtrinsicStatus\n\t\t\tsubmitExtrinsic(extrinsic: Extrinsic): Hash\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tepochAuthorship(): HashMap<AuthorityId, EpochAuthorship>\n\t\t`\n\t}, {\n\t\tname: \"Beefy\", rpc_path: \"beefy\",\n\t\tfuncs: `\n\t\t\tsubscribeJustifications(): BeefySignedCommitment\n\t\t`\n\t}, {\n\t\tname: \"Chain\", rpc_path: \"chain\",\n\t\tfuncs: `\n\t\t\tgetBlock(hash?: BlockHash): SignedBlock\n\t\t\tgetBlockHash(blockNumber?: BlockNumber): BlockHash\n\t\t\tgetFinalizedHead(): BlockHash\n\t\t\tgetHeader(hash?: BlockHash): Header\n\t\t\tsubscribeAllHeads(): Header\n\t\t\tsubscribeFinalizedHeads(): Header\n\t\t\tsubscribeNewHeads(): Header\n\t\t`\n\t}, {\n\t\tname: \"ChildState\", rpc_path: \"childstate\",\n\t\tfuncs: `\n\t\t\tgetKeys(childKey: PrefixedStorageKey, prefix: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetKeysPaged(childKey: PrefixedStorageKey, prefix: StorageKey, count: u32, startKey?: StorageKey, at?: Hash): Vec<StorageKey>\n\t\t\tgetStorage(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<StorageData>\n\t\t\tgetStorageEntries(childKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: Hash): Vec<Option<StorageData>>\n\t\t\tgetStorageHash(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<Hash>\n\t\t\tgetStorageSize(childKey: PrefixedStorageKey, key: StorageKey, at?: Hash): Option<u64>\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tcall(callRequest: ContractCallRequest, at?: BlockHash): ContractExecResult\n\t\t\tgetStorage(address: AccountId, key: H256, at?: BlockHash): Option<Bytes>\n\t\t\tinstantiate(request: InstantiateRequest, at?: BlockHash): ContractInstantiateResult\n\t\t\trentProjection(address: AccountId, at?: BlockHash): Option<BlockNumber>\n\t\t`\n\t}, {\n\t\tname: \"Engine\", rpc_path: \"engine\",\n\t\tfuncs: `\n\t\t\tcreateBlock(createEmpty: bool, finalize: bool, parentHash?: BlockHash): CreatedBlock\n\t\t\tfinalizeBlock(hash: BlockHash, justification?: Justification): bool\n\t\t`\n\t}, {\n\t\tname: \"Eth\", rpc_path: \"eth\",\n\t\tfuncs: `\n\t\t\taccounts(): Vec<H160>\n\t\t\tblockNumber(): U256\n\t\t\tcall(request: EthCallRequest, number?: BlockNumber): Bytes\n\t\t\tchainId(): U64\n\t\t\tcoinbase(): H160\n\t\t\testimateGas(request: EthCallRequest, number?: BlockNumber): U256\n\t\t\tgasPrice(): U256\n\t\t\tgetBalance(address: H160, number?: BlockNumber): U256\n\t\t\tgetBlockByHash(hash: H256, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockByNumber(block: BlockNumber, full: bool): Option<EthRichBlock>\n\t\t\tgetBlockTransactionCountByHash(hash: H256): U256\n\t\t\tgetBlockTransactionCountByNumber(block: BlockNumber): U256\n\t\t\tgetCode(address: H160, number?: BlockNumber): Bytes\n\t\t\tgetFilterChanges(index: U256): EthFilterChanges\n\t\t\tgetFilterLogs(index: U256): Vec<EthLog>\n\t\t\tgetLogs(filter: EthFilter): Vec<EthLog>\n\t\t\tgetProof(address: H160, storageKeys: Vec<H256>, number: BlockNumber): EthAccount\n\t\t\tgetStorageAt(address: H160, index: U256, number?: BlockNumber): H256\n\t\t\tgetTransactionByBlockHashAndIndex(hash: H256, index: U256): EthTransaction\n\t\t\tgetTransactionByBlockNumberAndIndex(number: BlockNumber, index: U256): EthTransaction\n\t\t\tgetTransactionByHash(hash: H256): EthTransaction\n\t\t\tgetTransactionCount(hash: H256, number?: BlockNumber): U256\n\t\t\tgetTransactionReceipt(hash: H256): EthReceipt\n\t\t\tgetUncleByBlockHashAndIndex(hash: H256, index: U256): EthRichBlock\n\t\t\tgetUncleByBlockNumberAndIndex(number: BlockNumber, index: U256): EthRichBlock\n\t\t\tgetUncleCountByBlockHash(hash: H256): U256\n\t\t\tgetUncleCountByBlockNumber(number: BlockNumber): U256\n\t\t\tgetWork(): EthWork\n\t\t\thashrate(): U256\n\t\t\tmining(): bool\n\t\t\tnewBlockFilter(): U256\n\t\t\tnewFilter(filter: EthFilter): U256\n\t\t\tnewPendingTransactionFilter(): U256\n\t\t\tprotocolVersion(): u64\n\t\t\tsendRawTransaction(bytes: Bytes): H256\n\t\t\tsendTransaction(tx: EthTransactionRequest): H256\n\t\t\tsubmitHashrate(index: U256, hash: H256): bool\n\t\t\tsubmitWork(nonce: H64, headerHash: H256, mixDigest: H256): bool\n\t\t\tsubscribe(kind: EthSubKind, params?: EthSubParams): Null\n\t\t\tsyncing(): EthSyncStatus\n\t\t\tuninstallFilter(index: U256): bool\n\t\t`\n\t}, {\n\t\tname: \"Eth/Net\", rpc_path: \"net\",\n\t\tfuncs: `\n\t\t\tlistening(): bool\n\t\t\tpeerCount(): String\n\t\t\tversion(): String\n\t\t`\n\t}, {\n\t\tname: \"Eth/Web3\", rpc_path: \"web3\",\n\t\tfuncs: `\n\t\t\tclientVersion(): String\n\t\t\tsha3(data: Bytes): H256\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tproveFinality(begin: BlockHash, end: BlockHash, authoritiesSetId?: u64): Option<EncodedFinalityProofs>\n\t\t\troundState(): ReportedRoundStates\n\t\t\tsubscribeJustifications(): JustificationNotification\n\t\t`\n\t}, {\n\t\tname: \"Mmr\", rpc_path: \"mmr\",\n\t\tfuncs: `\n\t\t\tgenerateProof(leafIndex: u64, at?: BlockHash): MmrLeafProof\n\t\t`\n\t}, {\n\t\tname: \"OffChain\", rpc_path: \"offchain\",\n\t\tfuncs: `\n\t\t\tlocalStorageGet(kind: StorageKind, key: Bytes): Option<Bytes>\n\t\t\tlocalStorageSet(kind: StorageKind, key: Bytes, value: Bytes): Null\n\t\t`\n\t}, {\n\t\tname: \"Payment\", rpc_path: \"payment\",\n\t\tfuncs: `\n\t\t\tqueryFeeDetails(extrinsic: Bytes, at?: BlockHash): FeeDetails\n\t\t\tqueryInfo(extrinsic: Bytes, at?: BlockHash): RuntimeDispatchInfo\n\t\t`\n\t}, {\n\t\tname: \"RPC\", rpc_path: \"rpc\",\n\t\tfuncs: `\n\t\t\tmethods(): RpcMethods\n\t\t`\n\t}, {\n\t\tname: \"State\", rpc_path: \"state\",\n\t\tfuncs: `\n\t\t\tcall(method: Text, data: Bytes, at?: BlockHash): Bytes\n\t\t\tgetChildKeys(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetChildReadProof(childStorageKey: PrefixedStorageKey, keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetChildStorage(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetChildStorageHash(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetChildStorageSize(childStorageKey: StorageKey, childDefinition: StorageKey, childType: u32, key: StorageKey, at?: BlockHash): u64\n\t\t\tgetKeys(key: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetKeysPaged(key: StorageKey, count: u32, startKey?: StorageKey, at?: BlockHash): Vec<StorageKey>\n\t\t\tgetMetadata(at?: BlockHash): Metadata\n\t\t\tgetPairs(prefix: StorageKey, at?: BlockHash): Vec<KeyValue>\n\t\t\tgetReadProof(keys: Vec<StorageKey>, at?: BlockHash): ReadProof\n\t\t\tgetRuntimeVersion(at?: BlockHash): RuntimeVersion\n\t\t\tgetStorage(key: StorageKey, at?: BlockHash): StorageData\n\t\t\tgetStorageHash(key: StorageKey, at?: BlockHash): Hash\n\t\t\tgetStorageSize(key: StorageKey, at?: BlockHash): u64\n\t\t\tqueryStorage(keys: Vec<StorageKey>, fromBlock: Hash, toBlock?: BlockHash): Vec<StorageChangeSet>\n\t\t\tqueryStorageAt(keys: Vec<StorageKey>, at?: BlockHash): Vec<StorageChangeSet>\n\t\t\tsubscribeRuntimeVersion(): RuntimeVersion\n\t\t\tsubscribeStorage(keys?: Vec<StorageKey>): StorageChangeSet\n\t\t\ttraceBlock(block: Hash, targets: Option<Text>, storageKeys: Option<Text>, methods: Option<Text>): TraceBlockResponse\n\t\t`\n\t}, {\n\t\tname: \"SyncState\", rpc_path: \"syncstate\",\n\t\tfuncs: `\n\t\t\tgenSyncSpec(raw: bool): Json\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\taccountNextIndex(accountId: AccountId): Index\n\t\t\taddLogFilter(directives: Text): Null\n\t\t\taddReservedPeer(peer: Text): Text\n\t\t\tchain(): Text\n\t\t\tchainType(): ChainType\n\t\t\tdryRun(extrinsic: Bytes, at?: BlockHash): ApplyExtrinsicResult\n\t\t\thealth(): Health\n\t\t\tlocalListenAddresses(): Vec<Text>\n\t\t\tlocalPeerId(): Text\n\t\t\tname(): Text\n\t\t\tnetworkState(): NetworkState\n\t\t\tnodeRoles(): Vec<NodeRole>\n\t\t\tpeers(): Vec<PeerInfo>\n\t\t\tproperties(): ChainProperties\n\t\t\tremoveReservedPeer(peerId: Text): Text\n\t\t\treservedPeers(): Vec<Text>\n\t\t\tresetLogFilter(): Null\n\t\t\tsyncState(): SyncState\n\t\t\tversion(): Text\n\t\t`\n\t}\n]);\n\n/**\n * For extracting function name, parameter, and return types\n * @param  String str function list to be extracted\n * @return Array\n */\nfunction functionParser(str, options){\n\t// Clean the spaces and split the new line\n\tlet list = str.trim().replace(/\\t+| /g, '').split('\\n');\n\n\t// For each lines\n\tfor (var i = 0; i < list.length; i++) {\n\t\tlet temp = list[i];\n\t\tlet funcName, args, returnType;\n\n\t\t// Implementation below can be replaced with RegExp, but more complicated I think\n\n\t\t// For Substrate Extrinsics that doesn't return value\n\t\tif(options.returnType === false)\n\t\t\ttemp += ':Any';\n\n\t\t// For Substrate Constants\n\t\tif(options.isConst)\n\t\t\ttemp = temp.replace(':', '():');\n\n\t\t// Separate name, parameter, and types\n\t\t// ex: hasSessionKeys(sessionKeys:Bytes):bool\n\t\t;([temp, returnType] = temp.split('):'));\n\t\t;([funcName, args] = temp.split('('));\n\n\t\tif(args === void 0) console.error(`Incorrect format \"${temp}\", `);\n\n\t\tlet argsName = [];\n\t\tif(!options.typeAsName){\n\t\t\t// Get the parameters/arguments name\n\t\t\targs = args.replace(/,?([a-zA-Z0-9_?]+):/g, function(full, name){\n\t\t\t\targsName.push(name);\n\t\t\t\treturn ';;'; // Remove the parameter name from the text\n\t\t\t})\n\t\t\t.replace(/^;;/m, ''); // Remove the first ';;'\n\t\t}\n\t\telse{\n\t\t\ttry {\n\t\t\t\targsName = args.split(',');\n\t\t\t\targs = argsName.join(';;');\n\t\t\t} catch(e) {\n\t\t\t\tconsole.error(`Incorrect format \"${temp}\", `, e);\n\t\t\t}\n\t\t}\n\n\t\t// Let's obtain the function parameter's type data\n\t\tlet argsObj = {};\n\t\tif(args !== ''){\n\t\t\targs = args.split(';;');\n\n\t\t\t// For each type data on the parameters\n\t\t\tfor (var a = 0; a < args.length; a++) {\n\t\t\t\tlet name = argsName[a];\n\n\t\t\t\t// Capitalize first word and assign it to argsObj\n\t\t\t\t// SessionKeys => Bytes\n\t\t\t\tname = name.slice(0, 1).toUpperCase() + name.slice(1);\n\t\t\t\targsObj[name] = args[a];\n\t\t\t}\n\t\t}\n\n\t\t// Put the extraction in the 'list'\n\t\tlist[i] = {\n\t\t\tname: funcName.slice(0, 1).toUpperCase() + funcName.slice(1),\n\t\t\targs: argsObj,\n\t\t\treturnType\n\t\t};\n\t}\n\n\treturn list;\n}\n\n/**\n * Generate Blackprint nodes for Substrate RPC\n * @param Array list [description]\n */\nfunction Substrate_BlackprintNodeGenerator(options, list){\n\tif(SubstrateMetadata === false) return;\n\n\tlet { namespace, description, apiPath, isConst } = options;\n\n\t// For each array items\n\tfor (var i = 0; i < list.length; i++) {\n\t\tlet temp = list[i];\n\t\tlet funcs = functionParser(temp.funcs, options);\n\n\t\t// For each extracted function from the string\n\t\tthat: for (var a = 0; a < funcs.length; a++) {\n\t\t\tlet func = funcs[a];\n\n\t\t\t// Skip subscribe or watch because it was an event\n\t\t\t// We will create separate nodes to handle subscribe/unsubscribe\n\t\t\tif(/subscribe|watch/i.test(func.name) && !options.loose){\n\t\t\t\tif(SubstrateSubscriber[func.name] === void 0)\n\t\t\t\t\tconsole.error(`Substrate subscriber for \"${func.name}\" was not found`);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If you found error from this line, then the SubstrateTypeData need to be updated\n\t\t\tif(SubstrateTypeData[func.returnType] === void 0 && !options.loose){\n\t\t\t\tconsole.error(`Substrate type data for \"${func.returnType}\" was not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t// Type mapping (Rust Types => JavaScript Types)\n\t\t\tlet returnToField = func.returnType;\n\t\t\tlet preprocessType = null;\n\t\t\tif(func.returnType !== 'Null'){\n\t\t\t\t// Simplify port name\n\t\t\t\tlet portName = func.returnType\n\t\t\t\t\t.replace(/(Vec|Option|HashMap)<(.*?)>$/m, function(full, wrapper, type){\n\t\t\t\t\t\tif(wrapper === 'Option' || wrapper === 'Vec')\n\t\t\t\t\t\t\treturn type;\n\n\t\t\t\t\t\t// ToDO: HashMap\n\t\t\t\t\t\treturn type;\n\t\t\t\t\t});\n\n\t\t\t\tif(options.loose && SubstrateTypeData[func.returnType] === void 0)\n\t\t\t\t\tSubstrateTypeData[func.returnType] = null;\n\n\t\t\t\tpreprocessType = SubstrateTypeData[func.returnType];\n\n\t\t\t\t// This will be used as output port\n\t\t\t\t// port name => type\n\t\t\t\tfunc.returnType = {\n\t\t\t\t\t[portName]: SubstrateTypeData[func.returnType]\n\t\t\t\t};\n\n\t\t\t\treturnToField = portName;\n\t\t\t}\n\t\t\telse func.returnType = void 0; // Didn't return data\n\n\t\t\t// Type mapping (Rust Types => JavaScript Types)\n\t\t\tlet args = func.args;\n\t\t\tlet RPCParams = Object.keys(args);\n\t\t\tfor(let portName in args){\n\t\t\t\tlet typeData = args[portName];\n\n\t\t\t\tif(options.loose && SubstrateTypeData[typeData] === void 0)\n\t\t\t\t\tSubstrateTypeData[typeData] = null;\n\n\t\t\t\t// If you found error from this line, then the SubstrateTypeData need to be updated\n\t\t\t\tif(SubstrateTypeData[typeData] === void 0){\n\t\t\t\t\tconsole.error(`Substrate type data for \"${typeData}\" was not found`);\n\t\t\t\t\tcontinue that;\n\t\t\t\t}\n\n\t\t\t\t// This will be used as input port\n\t\t\t\t// port name => type\n\t\t\t\targs[portName] = SubstrateTypeData[typeData];\n\t\t\t}\n\n\t\t\t// Categorizing Blackprint Node's path by function name\n\t\t\tlet funcName = func.name\n\t\t\t.replace(/By([A-Z].*)/, function(full, name){\n\t\t\t\treturn ' By/'+name;\n\t\t\t})\n\t\t\t.replace(/^(Get|Set|Has|New)([A-Z].*)/, function(full, category, name){\n\t\t\t\treturn category + '/' +name;\n\t\t\t})\n\t\t\t// Add space between words\n\t\t\t.replace(/([a-z])([A-Z])/g, function(full, A, B){\n\t\t\t\treturn A + ' ' +B;\n\t\t\t});\n\n\t\t\t// Capitalize the first character\n\t\t\tlet apiName = func.name.slice(0, 1).toLowerCase() + func.name.slice(1);\n\n\t\t\tlet defaultInput = {\n\t\t\t\tAPI: polkadotApi.ApiPromise,\n\t\t\t\tTrigger: Blackprint.Port.Trigger(function(){\n\t\t\t\t\tthis.trigger(); // this.trigger => async trigger()\n\t\t\t\t})\n\t\t\t};\n\n\t\t\t// For Substrate Constants\n\t\t\tif(isConst) delete defaultInput.Trigger;\n\n\t\t\t// Custom Node class\n\t\t\tclass GeneratedNode extends Blackprint.Node {\n\t\t\t\t// Output port, this can be undefined if return nothing (no output port)\n\t\t\t\tstatic output = func.returnType;\n\n\t\t\t\t// Input port for each nodes\n\t\t\t\tstatic input = Object.assign(defaultInput, args);\n\n\t\t\t\tconstructor(instance){\n\t\t\t\t\tsuper(instance);\n\n\t\t\t\t\t// Use default interface\n\t\t\t\t\tlet iface = this.setInterface();\n\t\t\t\t\tiface.title = `${temp.name} ${func.name}`; // ex: Author HasKey\n\t\t\t\t\tiface.description = description;\n\n\t\t\t\t\t// For showing toast above the node\n\t\t\t\t\tthis._toast = new NodeToast(iface);\n\t\t\t\t}\n\n\t\t\t\t// This will be called by the engine if the input port have a new value\n\t\t\t\tupdate(){\n\t\t\t\t\tlet {Input, Output} = this.ref; // Shortcut\n\t\t\t\t\tthis._toast.clear();\n\n\t\t\t\t\tif(Input.API != null){\n\t\t\t\t\t\tif(Input.API[apiPath][temp.rpc_path][apiName] == null){\n\t\t\t\t\t\t\tthis._toast.error(\"This network doesn't support this feature\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse Output[returnToField] = null;\n\n\t\t\t\t\t// For Substrate Constants\n\t\t\t\t\tif(isConst) this.trigger();\n\t\t\t\t}\n\n\t\t\t\t// This will be triggered from input port (input.Trigger)\n\t\t\t\tasync trigger(){\n\t\t\t\t\tlet {Input, Output} = this.ref; // Shortcut\n\t\t\t\t\tlet toast = this._toast;\n\n\t\t\t\t\tif(Input.API === null)\n\t\t\t\t\t\treturn toast.warn(\"API is required\");\n\n\t\t\t\t\t// Get reference, ex: rpc_path = author\n\t\t\t\t\tlet obj = Input.API[apiPath][temp.rpc_path];\n\n\t\t\t\t\t// Prepare arguments before calling the Polkadot.js's RPC function\n\t\t\t\t\tlet args = [];\n\t\t\t\t\tfor (var i = 0; i < RPCParams.length; i++) {\n\t\t\t\t\t\targs.push(Input[RPCParams[i]]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Call the RPC function and put the result to the output port\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar response = isConst ? obj[apiName] : await obj[apiName].apply(obj, args);\n\t\t\t\t\t} catch(e) {\n\t\t\t\t\t\tOutput[returnToField] = null;\n\t\t\t\t\t\ttoast.error(e.message);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(preprocessType != null)\n\t\t\t\t\t\tresponse = preprocessType(response);\n\n\t\t\t\t\t// ToDo: should we use type data's name as the port name?\n\t\t\t\t\tOutput[returnToField] = response;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Register it as Blackprint Node\n\t\t\tBlackprint.registerNode(`Polkadot.js/${namespace}/${temp.name}/${funcName}`, GeneratedNode);\n\t\t}\n\t}\n}","Blackprint.registerNode(\"Polkadot.js/Account/Transfer\",\nclass TransferNode extends Blackprint.Node {\n\tstatic input = {\n\t\tAPI: polkadotApi.ApiPromise,\n\t\tAddress: String, // base58\n\t\tValue: String, // in pico unit, 1e12 (pico) = 1 Dot\n\t};\n\tstatic output = {\n\t\tTxn: Transaction,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Transfer\";\n\t\tiface.description = \"Transfer balance to an address\";\n\t}\n\n\timported(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet toast = new NodeToast(this.iface);\n\n\t\tfunction onChanged(){\n\t\t\tif(!Input.Address)\n\t\t\t\treturn toast.warn(\"Address is required\");\n\n\t\t\tif(!Input.Value)\n\t\t\t\treturn toast.warn(\"Value is required\");\n\n\t\t\tif(Input.API === null)\n\t\t\t\treturn toast.warn(\"API is required\");\n\n\t\t\ttoast.clear();\n\n\t\t\tlet txn = Input.API.tx.balances.transfer(Input.Address, +Input.Value);\n\t\t\tOutput.Txn = new Transaction(txn);\n\t\t}\n\n\t\tthis.iface.on('port.value', Context.EventSlot, onChanged);\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, function({ port }){\n\t\t\tif(port.source === 'input') onChanged();\n\t\t});\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window;\n */\n\n// For storing node data\nclass ConnectionHTTPData {\n\tconstructor(iface){this._iface = iface}\n\n\t// example:  https://rpc.polkadot.io\n\t_rpcURL = '';\n\tget rpcURL(){return this._rpcURL}\n\tset rpcURL(val){\n\t\tthis._rpcURL = val;\n\t\tthis._iface.changeRPC();\n\t}\n}\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Connection/HTTP\",\nclass HTTPNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\tReconnect: Blackprint.Port.Trigger(function(){\n\t\t\tthis.iface.changeRPC();\n\t\t}),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tProvider: polkadotApi.HttpProvider,\n\t\tAPI: polkadotApi.ApiPromise,\n\t\tConnected: Function,\n\t\tDisconnected: Function,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./HTTP.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/HTTP');\n\t\tiface.title = \"HTTP\";\n\t\tiface.description = \"Web3 RPC Connection\";\n\n\t\t// Create new object for storing data\n\t\tiface.data = new ConnectionHTTPData(iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(data){\n\t\tif(!data) return;\n\n\t\t// This will also trigger \"iface.changeRPC\"\n\t\t// due to getter/setter on \"ConnectionHTTPData\"\n\t\tObject.assign(this.iface.data, data);\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tlet http = this.ref.Output.Provider;\n\t\tif(http === void 0) return;\n\n\t\t// Disconnect from the network\n\t\thttp.disconnect();\n\t\tthis.ref.Output.Disconnected();\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/HTTP',\nContext.IFace.ConnectionHTTP = class HTTPIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n\n\tasync changeRPC(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tthis._toast.clear();\n\n\t\t// This can be filled from sketch's UI, or with code by accessing the IFace\n\t\tlet rpcURL = this.data.rpcURL;\n\t\tif(!rpcURL)\n\t\t\treturn this._toast.error(\"RPC URL was empty\");\n\n\t\tif(!/^(https|http):\\/\\//.test(rpcURL))\n\t\t\treturn this._toast.error(\"The endpoint should start with http:// or https://\");\n\n\t\t// If already connected to other network, let's disconnect it first\n\t\tif(Output.Provider != null){\n\t\t\tOutput.Provider.disconnect();\n\t\t\tOutput.Disconnected();\n\t\t}\n\n\t\t// Connect to the new RPC URL\n\t\tlet provider = Output.Provider = new polkadotApi.HttpProvider(rpcURL);\n\n\t\tthis._toast.warn(\"Connecting...\");\n\n\t\t// Wait until connected, or show warning when failed\n\t\ttry {\n\t\t\tvar api = await polkadotApi.ApiPromise.create({ provider, throwOnConnect: true });\n\t\t} catch(e) {\n\t\t\tthis._toast.warn(\"Connection failed\");\n\t\t\tOutput.API = null;\n\t\t\tOutput.Disconnected();\n\t\t\treturn;\n\t\t}\n\n\t\t// Put the API object into the output port\n\t\tOutput.API = api;\n\n\t\t// Check connection status\n\t\tif(provider.isConnected){\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.success(\"Connected\");\n\n\t\t\tOutput.Connected();\n\t\t}\n\t\telse{\n\t\t\tthis._toast.error(\"Failed to connect\");\n\t\t\tOutput.Disconnected();\n\t\t}\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window;\n */\n\n// For storing node data\nclass ConnectionWebSocketData {\n\tconstructor(iface){this._iface = iface}\n\n\t// example:  wss://rpc.polkadot.io\n\t_rpcURL = '';\n\tget rpcURL(){return this._rpcURL}\n\tset rpcURL(val){\n\t\tthis._rpcURL = val;\n\t\tthis._iface.changeRPC();\n\t}\n}\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Connection/WebSocket\",\nclass WebSocketNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\tConnect: Blackprint.Port.Trigger(function(){\n\t\t\tthis.output.Provider?.connect();\n\t\t}),\n\t\tDisconnect: Blackprint.Port.Trigger(function(){\n\t\t\tthis.output.Provider?.disconnect();\n\t\t}),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tProvider: polkadotApi.WsProvider,\n\t\tAPI: polkadotApi.ApiPromise,\n\t\tConnected: Function,\n\t\tDisconnected: Function,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./WebSocket.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Connection/WebSocket');\n\t\tiface.title = \"WebSocket\";\n\t\tiface.description = \"Web3 RPC Connection\";\n\n\t\tiface.data = new ConnectionWebSocketData(iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(data){\n\t\tif(!data) return;\n\t\tObject.assign(this.iface.data, data);\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tlet ws = this.ref.Output.Provider;\n\t\tif(ws === void 0) return;\n\n\t\t// Disconnect from the network\n\t\tws.disconnect();\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Connection/WebSocket',\nContext.IFace.ConnectionWebSocket = class WebSocketIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis._toast = new NodeToast(this);\n\t\tthis._toast.warn(\"Disconnected\");\n\t}\n\n\tasync changeRPC(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tthis._toast.clear();\n\n\t\t// If already connected to other network, let's disconnect it first\n\t\tOutput.Provider?.disconnect();\n\n\t\t// This can be filled from sketch's UI, or with code by accessing the IFace\n\t\tlet rpcURL = this.data.rpcURL;\n\t\tif(!rpcURL)\n\t\t\treturn this._toast.error(\"RPC URL was empty\");\n\n\t\tif(!/^(wss|ws):\\/\\//.test(rpcURL))\n\t\t\treturn this._toast.error(\"The endpoint should start with ws:// or wss://\");\n\n\t\t// Connect to the new RPC URL and put the Provider object to the output port\n\t\tlet provider = Output.Provider = new polkadotApi.WsProvider(rpcURL);\n\n\t\t// Add event listener before connecting to the network\n\t\tprovider.on('connected', ()=> {\n\t\t\tthis._toast.clear();\n\t\t\tthis._toast.success(\"Connected\");\n\t\t\tOutput.Connected();\n\t\t});\n\n\t\tprovider.on('disconnected', ()=> {\n\t\t\tthis._toast.warn(\"Disconnected\");\n\t\t\tOutput.Disconnected();\n\t\t});\n\n\t\t// Wait until connected and put the API object into the output port\n\t\tthis._toast.warn(\"Connecting...\");\n\t\tOutput.API = await polkadotApi.ApiPromise.create({ provider });\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../RPC/generator.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/constants\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Constants',\n\tdescription: '[Experimental] Substrate Constants',\n\tapiPath: 'consts',\n\tloose: true,\n\tisConst: true,\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\tapprovalDeposit: u128\n\t\t\tassetAccountDeposit: u128\n\t\t\tassetDeposit: u128\n\t\t\tmetadataDepositBase: u128\n\t\t\tmetadataDepositPerByte: u128\n\t\t\tstringLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tuncleGenerations: u32\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tepochDuration: u64\n\t\t\texpectedBlockTime: u64\n\t\t\tmaxAuthorities: u32\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tbagThresholds: Vec<u64>\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\texistentialDeposit: u128\n\t\t\tmaxLocks: u32\n\t\t\tmaxReserves: u32\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tbountyCuratorDeposit: Permill\n\t\t\tbountyDepositBase: u128\n\t\t\tbountyDepositPayoutDelay: u32\n\t\t\tbountyUpdatePeriod: u32\n\t\t\tbountyValueMinimum: u128\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tchildBountyCuratorDepositBase: Permill\n\t\t\tchildBountyValueMinimum: u128\n\t\t\tmaxActiveChildBountyCount: u32\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tdeletionQueueDepth: u32\n\t\t\tdeletionWeightLimit: u64\n\t\t\tdepositPerByte: u128\n\t\t\tdepositPerItem: u128\n\t\t\tschedule: PalletContractsSchedule\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tcooloffPeriod: u32\n\t\t\tenactmentPeriod: u32\n\t\t\tfastTrackVotingPeriod: u32\n\t\t\tinstantAllowed: bool\n\t\t\tlaunchPeriod: u32\n\t\t\tmaxProposals: u32\n\t\t\tmaxVotes: u32\n\t\t\tminimumDeposit: u128\n\t\t\tpreimageByteDeposit: u128\n\t\t\tvoteLockingPeriod: u32\n\t\t\tvotingPeriod: u32\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tminerMaxLength: u32\n\t\t\tminerMaxWeight: u64\n\t\t\tminerTxPriority: u64\n\t\t\toffchainRepeat: u32\n\t\t\tsignedDepositBase: u128\n\t\t\tsignedDepositByte: u128\n\t\t\tsignedDepositWeight: u128\n\t\t\tsignedMaxSubmissions: u32\n\t\t\tsignedMaxWeight: u64\n\t\t\tsignedPhase: u32\n\t\t\tsignedRewardBase: u128\n\t\t\tsolutionImprovementThreshold: Perbill\n\t\t\tunsignedPhase: u32\n\t\t\tvoterSnapshotPerBlock: u32\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcandidacyBond: u128\n\t\t\tdesiredMembers: u32\n\t\t\tdesiredRunnersUp: u32\n\t\t\tpalletId: [u8;8]\n\t\t\ttermDuration: u32\n\t\t\tvotingBondBase: u128\n\t\t\tvotingBondFactor: u128\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tfifoQueueLen: u32\n\t\t\tintakePeriod: u32\n\t\t\tmaxIntakeBids: u32\n\t\t\tmaxQueueLen: u32\n\t\t\tminFreeze: u128\n\t\t\tperiod: u32\n\t\t\tqueueCount: u32\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tmaxAuthorities: u32\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\tbasicDeposit: u128\n\t\t\tfieldDeposit: u128\n\t\t\tmaxAdditionalFields: u32\n\t\t\tmaxRegistrars: u32\n\t\t\tmaxSubAccounts: u32\n\t\t\tsubAccountDeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\tunsignedPriority: u64\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\tdeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tmaxCalls: u32\n\t\t\tmaxGenerateRandom: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tdepositBase: u128\n\t\t\tdepositFactor: u128\n\t\t\tmaxSignatories: u16\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\tannouncementDepositBase: u128\n\t\t\tannouncementDepositFactor: u128\n\t\t\tmaxPending: u32\n\t\t\tmaxProxies: u32\n\t\t\tproxyDepositBase: u128\n\t\t\tproxyDepositFactor: u128\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tconfigDepositBase: u128\n\t\t\tfriendDepositFactor: u128\n\t\t\tmaxFriends: u16\n\t\t\trecoveryDeposit: u128\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tmaximumWeight: u64\n\t\t\tmaxScheduledPerBlock: u32\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tcandidateDeposit: u128\n\t\t\tchallengePeriod: u32\n\t\t\tmaxCandidateIntake: u32\n\t\t\tmaxLockDuration: u32\n\t\t\tmaxStrikes: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tperiodSpend: u128\n\t\t\trotationPeriod: u32\n\t\t\twrongSideDeduction: u128\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tbondingDuration: u32\n\t\t\tmaxNominatorRewardedPerValidator: u32\n\t\t\tsessionsPerEra: u32\n\t\t\tslashDeferDuration: u32\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\tblockHashCount: u32\n\t\t\tblockLength: FrameSystemLimitsBlockLength\n\t\t\tblockWeights: FrameSystemLimitsBlockWeights\n\t\t\tdbWeight: FrameSupportWeightsRuntimeDbWeight\n\t\t\tss58Prefix: u16\n\t\t\tversion: SpVersionRuntimeVersion\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tminimumPeriod: u64\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\tdataDepositPerByte: u128\n\t\t\tmaximumReasonLength: u32\n\t\t\ttipCountdown: u32\n\t\t\ttipFindersFee: Percent\n\t\t\ttipReportDepositBase: u128\n\t\t`\n\t}, {\n\t\tname: \"TransactionPayment\", rpc_path: \"transactionPayment\",\n\t\tfuncs: `\n\t\t\toperationalFeeMultiplier: u8\n\t\t\ttransactionByteFee: u128\n\t\t\tweightToFee: Vec<FrameSupportWeightsWeightToFeeCoefficient>\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tburn: Permill\n\t\t\tmaxApprovals: u32\n\t\t\tpalletId: FrameSupportPalletId\n\t\t\tproposalBond: Permill\n\t\t\tproposalBondMaximum: Option<u128>\n\t\t\tproposalBondMinimum: u128\n\t\t\tspendPeriod: u32\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\tattributeDepositBase: u128\n\t\t\tclassDeposit: u128\n\t\t\tdepositPerByte: u128\n\t\t\tinstanceDeposit: u128\n\t\t\tkeyLimit: u32\n\t\t\tmetadataDepositBase: u128\n\t\t\tstringLimit: u32\n\t\t\tvalueLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Utility\", rpc_path: \"utility\",\n\t\tfuncs: `\n\t\t\tbatchedCallsLimit: u32\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tmaxVestingSchedules: u32\n\t\t\tminVestedTransfer: u128\n\t\t`\n\t}\n]);","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtilCrypto } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Convert/Mnemonic\",\nclass MnemonicNode extends Blackprint.Node {\n\t// Node's output/input port\n\tstatic input = { Text: String };\n\tstatic output = { Seed: Uint8Array };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Mnemonic\";\n\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.Text.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Seed = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet { mnemonicToMiniSecret, mnemonicValidate } = polkadotUtilCrypto;\n\t\tlet toast = this._toast;\n\n\t\ttry{\n\t\t\tif(!mnemonicValidate(Input.Text))\n\t\t\t\treturn toast.warn(\"Invalid mnemonic\");\n\n\t\t\t// Convert to seed that can be imported to Keyring and put it to the output port\n\t\t\tOutput.Seed = mnemonicToMiniSecret(Input.Text);\n\t\t\ttoast.clear();\n\t\t} catch(e) {\n\t\t\treturn toast.warn(e.message);\n\t\t}\n\t}\n});","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Data/Sign\",\nclass SignNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\tSigner: Signer,\n\t\tData: Blackprint.Port.Union([String, Uint8Array]),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tBytes: Uint8Array\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Sign\";\n\t\tiface.description = \"Data/transaction signer\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Bytes = null; // Clear the output data if something was fail/error\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Signer)\n\t\t\treturn this._fail(\"Signer is required\");\n\n\t\tlet data = Input.Data;\n\t\tif(!data)\n\t\t\treturn this._fail(\"Data is required\");\n\n\t\tlet { signer, address, isPair } = Input.Signer;\n\t\tthis._toast.clear();\n\n\t\t// There's 2 source of signer (from Keypair and Browser Extension)\n\n\t\tif(isPair){ // Signer from Keypair (polkadotApi.Keyring)\n\t\t\tif(data.constructor === String)\n\t\t\t\tdata = polkadotUtil.stringToU8a(data);\n\n\t\t\t// Sign with the keypair and put the data to the output port\n\t\t\tOutput.Bytes = signer.sign(data);\n\t\t}\n\t\telse { // Signer from extension (polkadotExtensionDapp)\n\t\t\tif(data.constructor === Uint8Array)\n\t\t\t\tdata = polkadotUtil.u8aToHex(data);\n\t\t\telse if(data.slice(0, 2) !== '0x')\n\t\t\t\tdata = polkadotUtil.stringToHex(data);\n\n\t\t\t// Sign with the extension and get the Hex\n\t\t\ttry{\n\t\t\t\tvar temp = await signer.signRaw({\n\t\t\t\t\ttype: 'bytes',\n\t\t\t\t\tdata,\n\t\t\t\t\taddress,\n\t\t\t\t});\n\t\t\t} catch(e) {\n\t\t\t\tthis._fail(e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\t// Convert the returned Hex to Uint8Array and put the data to the output port\n\t\t\tOutput.Bytes = polkadotUtil.hexToU8a(temp.signature);\n\t\t}\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil, polkadotUtilCrypto } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Data/Verify\",\nclass VerifyNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\tAddress: String, // base58\n\t\tSignature: Blackprint.Port.Union([String, Uint8Array]),\n\t\tData: Blackprint.Port.Union([String, Uint8Array]),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tIsValid: Boolean\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Verify\";\n\t\tiface.description = \"Verify signed message\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.IsValid = null; // Clear the output data if something was fail/error\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Data)\n\t\t\treturn this._fail(\"Data is required\");\n\n\t\tif(!Input.Address)\n\t\t\treturn this._fail(\"Address is required\");\n\n\t\tif(!Input.Signature)\n\t\t\treturn this._fail(\"Signature is required\");\n\n\t\t// If the Data was string, let's convert it to Uint8Array\n\t\tlet data = Input.Data;\n\t\tif(data.constructor === String){\n\t\t\tif(data.slice(0, 2) === '0x')\n\t\t\t\tdata = polkadotUtil.hexToU8a(data);\n\t\t\telse data = polkadotUtil.stringToU8a(data);\n\t\t}\n\n\t\t// If the Signature was string, maybe it was a Hex, let's convert it to Uint8Array\n\t\tlet sign = Input.Signature;\n\t\tif(sign.constructor === String){\n\t\t\tif(sign.slice(0, 2) === '0x')\n\t\t\t\tsign = polkadotUtil.hexToU8a(sign);\n\t\t\telse return this._fail(\"Signature must be Hex or Uint8Array\");\n\t\t}\n\n\t\t// Remove any node toast\n\t\tthis._toast.clear();\n\t\tawait polkadotUtilCrypto.cryptoWaitReady();\n\n\t\ttry{\n\t\t\t// Verify the message/data and the signature with the public key\n\t\t\tvar temp = polkadotUtilCrypto.signatureVerify(data, sign, Input.Address);\n\t\t} catch(e) {\n\t\t\tthis._fail(e.message);\n\t\t\tthrow e;\n\t\t}\n\n\t\tOutput.IsValid = temp.isValid;\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Events/Blocks\",\nclass BlocksNode extends Blackprint.Node {\n\t// Node type: event listener\n\tstatic type = 'event';\n\n\t// Input port\n\tstatic input = {\n\t\tAPI: polkadotApi.ApiPromise,\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tData: Object,\n\t\tNumber: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\t// Use custom interface\n\t\t// Engine: scroll down this file to \"Blackprint.registerInterface\"\n\t\t// Browser: ./Blocks.sf\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Events/Blocks');\n\t\tiface.title = \"Blocks Event\";\n\t\tiface.description = \"Listen for new blocks\";\n\n\t\tthis._toast = new NodeToast(iface);\n\t}\n\n\t// This will be called by the engine after the node has been loaded\n\t// and other data like cable connection has been connected/added\n\tinit(){\n\t\tlet { IInput } = this.ref; // Shortcut\n\n\t\t// Listen if the cable was disconnected from the input port\n\t\tIInput.API.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.iface.unsubscribe();\n\t\t});\n\t}\n\n\t// This will be called by the engine when this node is deleted\n\tdestroy(){\n\t\tthis.iface.unsubscribe();\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\t// If this node is already subscribing to blocks event, let's unsubscribe it\n\t\tthis.iface.unsubscribe();\n\n\t\tlet api = Input.API;\n\t\tif(!api) return;\n\n\t\tif(!api.hasSubscriptions)\n\t\t\treturn this._toast.error(\"Please use WebSocket for using this feature\");\n\n\t\tthis._toast.clear();\n\n\t\t// Subscribe to new heads/blocks and save the 'unsubscribe' function\n\t\tthis._toast.warn(\"Subscribing...\");\n\t\tthis.iface.unsubscribe = await api.rpc.chain.subscribeNewHeads(header => {\n\t\t\tOutput.Data = header;\n\t\t\tOutput.Number = this.iface.number = header.number.toNumber();\n\t\t});\n\n\t\t// Clear the toast\n\t\tthis._toast.clear();\n\t\tthis._toast.success(\"Subscribed!\");\n\t}\n});\n\n\n// Register Blackprint Interface (like an API for developer, or UI for sketch editor)\nBlackprint.registerInterface('BPIC/Polkadot.js/Events/Blocks',\nContext.IFace.EventsBlocks = class BlocksIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis.number = 0; // blocks number\n\n\t\t// This will be replaced if subcribing to an event, default: no operation\n\t\tthis.unsubscribe = ()=> {};\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../RPC/generator.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/storage\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Extrinsics',\n\tdescription: '[Experimental] Substrate Extrinsics',\n\tapiPath: 'tx',\n\tloose: true,\n\treturnType: false,\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\tapproveTransfer(id: Compact<u32>, delegate: MultiAddress, amount: Compact<u128>)\n\t\t\tburn(id: Compact<u32>, who: MultiAddress, amount: Compact<u128>)\n\t\t\tcancelApproval(id: Compact<u32>, delegate: MultiAddress)\n\t\t\tclearMetadata(id: Compact<u32>)\n\t\t\tcreate(id: Compact<u32>, admin: MultiAddress, min_balance: u128)\n\t\t\tdestroy(id: Compact<u32>, witness: PalletAssetsDestroyWitness)\n\t\t\tforceAssetStatus(id: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, min_balance: Compact<u128>, is_sufficient: bool, is_frozen: bool)\n\t\t\tforceCancelApproval(id: Compact<u32>, owner: MultiAddress, delegate: MultiAddress)\n\t\t\tforceClearMetadata(id: Compact<u32>)\n\t\t\tforceCreate(id: Compact<u32>, owner: MultiAddress, is_sufficient: bool, min_balance: Compact<u128>)\n\t\t\tforceSetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8, is_frozen: bool)\n\t\t\tforceTransfer(id: Compact<u32>, source: MultiAddress, dest: MultiAddress, amount: Compact<u128>)\n\t\t\tfreeze(id: Compact<u32>, who: MultiAddress)\n\t\t\tfreezeAsset(id: Compact<u32>)\n\t\t\tmint(id: Compact<u32>, beneficiary: MultiAddress, amount: Compact<u128>)\n\t\t\trefund(id: Compact<u32>, allow_burn: bool)\n\t\t\tsetMetadata(id: Compact<u32>, name: Bytes, symbol: Bytes, decimals: u8)\n\t\t\tsetTeam(id: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(id: Compact<u32>, who: MultiAddress)\n\t\t\tthawAsset(id: Compact<u32>)\n\t\t\ttouch(id: Compact<u32>)\n\t\t\ttransfer(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferApproved(id: Compact<u32>, owner: MultiAddress, destination: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferKeepAlive(id: Compact<u32>, target: MultiAddress, amount: Compact<u128>)\n\t\t\ttransferOwnership(id: Compact<u32>, owner: MultiAddress)\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tsetUncles(new_uncles: Vec<SpRuntimeHeader>)\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tplanConfigChange(config: SpConsensusBabeDigestsNextConfigDescriptor)\n\t\t\treportEquivocation(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpConsensusSlotsEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tputInFrontOf(lighter: AccountId32)\n\t\t\trebag(dislocated: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\tforceTransfer(source: MultiAddress, dest: MultiAddress, value: Compact<u128>)\n\t\t\tforceUnreserve(who: MultiAddress, amount: u128)\n\t\t\tsetBalance(who: MultiAddress, new_free: Compact<u128>, new_reserved: Compact<u128>)\n\t\t\ttransfer(dest: MultiAddress, value: Compact<u128>)\n\t\t\ttransferAll(dest: MultiAddress, keep_alive: bool)\n\t\t\ttransferKeepAlive(dest: MultiAddress, value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tacceptCurator(bounty_id: Compact<u32>)\n\t\t\tapproveBounty(bounty_id: Compact<u32>)\n\t\t\tawardBounty(bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimBounty(bounty_id: Compact<u32>)\n\t\t\tcloseBounty(bounty_id: Compact<u32>)\n\t\t\textendBountyExpiry(bounty_id: Compact<u32>, remark: Bytes)\n\t\t\tproposeBounty(value: Compact<u128>, description: Bytes)\n\t\t\tproposeCurator(bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(bounty_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tacceptCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\taddChildBounty(parent_bounty_id: Compact<u32>, value: Compact<u128>, description: Bytes)\n\t\t\tawardChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, beneficiary: MultiAddress)\n\t\t\tclaimChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tcloseChildBounty(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t\tproposeCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>, curator: MultiAddress, fee: Compact<u128>)\n\t\t\tunassignCurator(parent_bounty_id: Compact<u32>, child_bounty_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\tcall(dest: MultiAddress, value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, data: Bytes)\n\t\t\tinstantiate(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code_hash: H256, data: Bytes, salt: Bytes)\n\t\t\tinstantiateWithCode(value: Compact<u128>, gas_limit: Compact<u64>, storage_deposit_limit: Option<Compact<u128>>, code: Bytes, data: Bytes, salt: Bytes)\n\t\t\tremoveCode(code_hash: H256)\n\t\t\tuploadCode(code: Bytes, storage_deposit_limit: Option<Compact<u128>>)\n\t\t`\n\t}, {\n\t\tname: \"Council\", rpc_path: \"council\",\n\t\tfuncs: `\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tblacklist(proposal_hash: H256, maybe_ref_index: Option<u32>)\n\t\t\tcancelProposal(prop_index: Compact<u32>)\n\t\t\tcancelQueued(which: u32)\n\t\t\tcancelReferendum(ref_index: Compact<u32>)\n\t\t\tclearPublicProposals()\n\t\t\tdelegate(to: AccountId32, conviction: PalletDemocracyConviction, balance: u128)\n\t\t\temergencyCancel(ref_index: u32)\n\t\t\tenactProposal(proposal_hash: H256, index: u32)\n\t\t\texternalPropose(proposal_hash: H256)\n\t\t\texternalProposeDefault(proposal_hash: H256)\n\t\t\texternalProposeMajority(proposal_hash: H256)\n\t\t\tfastTrack(proposal_hash: H256, voting_period: u32, delay: u32)\n\t\t\tnoteImminentPreimage(encoded_proposal: Bytes)\n\t\t\tnoteImminentPreimageOperational(encoded_proposal: Bytes)\n\t\t\tnotePreimage(encoded_proposal: Bytes)\n\t\t\tnotePreimageOperational(encoded_proposal: Bytes)\n\t\t\tpropose(proposal_hash: H256, value: Compact<u128>)\n\t\t\treapPreimage(proposal_hash: H256, proposal_len_upper_bound: Compact<u32>)\n\t\t\tremoveOtherVote(target: AccountId32, index: u32)\n\t\t\tremoveVote(index: u32)\n\t\t\tsecond(proposal: Compact<u32>, seconds_upper_bound: Compact<u32>)\n\t\t\tundelegate()\n\t\t\tunlock(target: AccountId32)\n\t\t\tvetoExternal(proposal_hash: H256)\n\t\t\tvote(ref_index: Compact<u32>, vote: PalletDemocracyVoteAccountVote)\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tgovernanceFallback(maybe_max_voters: Option<u32>, maybe_max_targets: Option<u32>)\n\t\t\tsetEmergencyElectionResult(supports: Vec<(AccountId32,SpNposElectionsSupport)>)\n\t\t\tsetMinimumUntrustedScore(maybe_next_score: Option<[u128;3]>)\n\t\t\tsubmit(raw_solution: PalletElectionProviderMultiPhaseRawSolution, num_signed_submissions: u32)\n\t\t\tsubmitUnsigned(raw_solution: PalletElectionProviderMultiPhaseRawSolution, witness: PalletElectionProviderMultiPhaseSolutionOrSnapshotSize)\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcleanDefunctVoters(num_voters: u32, num_defunct: u32)\n\t\t\tremoveMember(who: MultiAddress, has_replacement: bool)\n\t\t\tremoveVoter()\n\t\t\trenounceCandidacy(renouncing: PalletElectionsPhragmenRenouncing)\n\t\t\tsubmitCandidacy(candidate_count: Compact<u32>)\n\t\t\tvote(votes: Vec<AccountId32>, value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tplaceBid(amount: Compact<u128>, duration: u32)\n\t\t\tretractBid(amount: Compact<u128>, duration: u32)\n\t\t\tsetTarget(target: Compact<Perquintill>)\n\t\t\tthaw(index: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tnoteStalled(delay: u32, best_finalized_block_number: u32)\n\t\t\treportEquivocation(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t\treportEquivocationUnsigned(equivocation_proof: SpFinalityGrandpaEquivocationProof, key_owner_proof: SpSessionMembershipProof)\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\taddRegistrar(account: AccountId32)\n\t\t\taddSub(sub: MultiAddress, data: Data)\n\t\t\tcancelRequest(reg_index: u32)\n\t\t\tclearIdentity()\n\t\t\tkillIdentity(target: MultiAddress)\n\t\t\tprovideJudgement(reg_index: Compact<u32>, target: MultiAddress, judgement: PalletIdentityJudgement)\n\t\t\tquitSub()\n\t\t\tremoveSub(sub: MultiAddress)\n\t\t\trenameSub(sub: MultiAddress, data: Data)\n\t\t\trequestJudgement(reg_index: Compact<u32>, max_fee: Compact<u128>)\n\t\t\tsetAccountId(index: Compact<u32>, new: AccountId32)\n\t\t\tsetFee(index: Compact<u32>, fee: Compact<u128>)\n\t\t\tsetFields(index: Compact<u32>, fields: PalletIdentityBitFlags)\n\t\t\tsetIdentity(info: PalletIdentityIdentityInfo)\n\t\t\tsetSubs(subs: Vec<(AccountId32,Data)>)\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\theartbeat(heartbeat: PalletImOnlineHeartbeat, signature: PalletImOnlineSr25519AppSr25519Signature)\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\tclaim(index: u32)\n\t\t\tforceTransfer(new: AccountId32, index: u32, freeze: bool)\n\t\t\tfree(index: u32)\n\t\t\tfreeze(index: u32)\n\t\t\ttransfer(new: AccountId32, index: u32)\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tbuyTicket(call: Call)\n\t\t\tsetCalls(calls: Vec<Call>)\n\t\t\tstartLottery(price: u128, length: u32, delay: u32, repeat: bool)\n\t\t\tstopRepeat()\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tapproveAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call_hash: [u8;32], max_weight: u64)\n\t\t\tasMulti(threshold: u16, other_signatories: Vec<AccountId32>, maybe_timepoint: Option<PalletMultisigTimepoint>, call: WrapperKeepOpaque<Call>, store_call: bool, max_weight: u64)\n\t\t\tasMultiThreshold1(other_signatories: Vec<AccountId32>, call: Call)\n\t\t\tcancelAsMulti(threshold: u16, other_signatories: Vec<AccountId32>, timepoint: PalletMultisigTimepoint, call_hash: [u8;32])\n\t\t`\n\t}, {\n\t\tname: \"Preimage\", rpc_path: \"preimage\",\n\t\tfuncs: `\n\t\t\tnotePreimage(bytes: Bytes)\n\t\t\trequestPreimage(hash: H256)\n\t\t\tunnotePreimage(hash: H256)\n\t\t\tunrequestPreimage(hash: H256)\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\taddProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t\tannounce(real: AccountId32, call_hash: H256)\n\t\t\tanonymous(proxy_type: NodeRuntimeProxyType, delay: u32, index: u16)\n\t\t\tkillAnonymous(spawner: AccountId32, proxy_type: NodeRuntimeProxyType, index: u16, height: Compact<u32>, ext_index: Compact<u32>)\n\t\t\tproxy(real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\tproxyAnnounced(delegate: AccountId32, real: AccountId32, force_proxy_type: Option<NodeRuntimeProxyType>, call: Call)\n\t\t\trejectAnnouncement(delegate: AccountId32, call_hash: H256)\n\t\t\tremoveAnnouncement(real: AccountId32, call_hash: H256)\n\t\t\tremoveProxies()\n\t\t\tremoveProxy(delegate: AccountId32, proxy_type: NodeRuntimeProxyType, delay: u32)\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tasRecovered(account: AccountId32, call: Call)\n\t\t\tcancelRecovered(account: AccountId32)\n\t\t\tclaimRecovery(account: AccountId32)\n\t\t\tcloseRecovery(rescuer: AccountId32)\n\t\t\tcreateRecovery(friends: Vec<AccountId32>, threshold: u16, delay_period: u32)\n\t\t\tinitiateRecovery(account: AccountId32)\n\t\t\tremoveRecovery()\n\t\t\tsetRecovered(lost: AccountId32, rescuer: AccountId32)\n\t\t\tvouchRecovery(lost: AccountId32, rescuer: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tcancel(when: u32, index: u32)\n\t\t\tcancelNamed(id: Bytes)\n\t\t\tschedule(when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleAfter(after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamed(id: Bytes, when: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t\tscheduleNamedAfter(id: Bytes, after: u32, maybe_periodic: Option<(u32,u32)>, priority: u8, call: FrameSupportScheduleMaybeHashed)\n\t\t`\n\t}, {\n\t\tname: \"Session\", rpc_path: \"session\",\n\t\tfuncs: `\n\t\t\tpurgeKeys()\n\t\t\tsetKeys(keys: NodeRuntimeSessionKeys, proof: Bytes)\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tbid(value: u128)\n\t\t\tdefenderVote(approve: bool)\n\t\t\tfound(founder: AccountId32, max_members: u32, rules: Bytes)\n\t\t\tjudgeSuspendedCandidate(who: AccountId32, judgement: PalletSocietyJudgement)\n\t\t\tjudgeSuspendedMember(who: AccountId32, forgive: bool)\n\t\t\tpayout()\n\t\t\tsetMaxMembers(max: u32)\n\t\t\tunbid(pos: u32)\n\t\t\tunfound()\n\t\t\tunvouch(pos: u32)\n\t\t\tvote(candidate: MultiAddress, approve: bool)\n\t\t\tvouch(who: AccountId32, value: u128, tip: u128)\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tbond(controller: MultiAddress, value: Compact<u128>, payee: PalletStakingRewardDestination)\n\t\t\tbondExtra(max_additional: Compact<u128>)\n\t\t\tcancelDeferredSlash(era: u32, slash_indices: Vec<u32>)\n\t\t\tchill()\n\t\t\tchillOther(controller: AccountId32)\n\t\t\tforceNewEra()\n\t\t\tforceNewEraAlways()\n\t\t\tforceNoEras()\n\t\t\tforceUnstake(stash: AccountId32, num_slashing_spans: u32)\n\t\t\tincreaseValidatorCount(additional: Compact<u32>)\n\t\t\tkick(who: Vec<MultiAddress>)\n\t\t\tnominate(targets: Vec<MultiAddress>)\n\t\t\tpayoutStakers(validator_stash: AccountId32, era: u32)\n\t\t\treapStash(stash: AccountId32, num_slashing_spans: u32)\n\t\t\trebond(value: Compact<u128>)\n\t\t\tscaleValidatorCount(factor: Percent)\n\t\t\tsetController(controller: MultiAddress)\n\t\t\tsetHistoryDepth(new_history_depth: Compact<u32>, era_items_deleted: Compact<u32>)\n\t\t\tsetInvulnerables(invulnerables: Vec<AccountId32>)\n\t\t\tsetPayee(payee: PalletStakingRewardDestination)\n\t\t\tsetStakingConfigs(min_nominator_bond: u128, min_validator_bond: u128, max_nominator_count: Option<u32>, max_validator_count: Option<u32>, chill_threshold: Option<Percent>, min_commission: Perbill)\n\t\t\tsetValidatorCount(new: Compact<u32>)\n\t\t\tunbond(value: Compact<u128>)\n\t\t\tvalidate(prefs: PalletStakingValidatorPrefs)\n\t\t\twithdrawUnbonded(num_slashing_spans: u32)\n\t\t`\n\t}, {\n\t\tname: \"Sudo\", rpc_path: \"sudo\",\n\t\tfuncs: `\n\t\t\tsetKey(new: MultiAddress)\n\t\t\tsudo(call: Call)\n\t\t\tsudoAs(who: MultiAddress, call: Call)\n\t\t\tsudoUncheckedWeight(call: Call, weight: u64)\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\tfillBlock(ratio: Perbill)\n\t\t\tkillPrefix(prefix: Bytes, subkeys: u32)\n\t\t\tkillStorage(keys: Vec<Bytes>)\n\t\t\tremark(remark: Bytes)\n\t\t\tremarkWithEvent(remark: Bytes)\n\t\t\tsetCode(code: Bytes)\n\t\t\tsetCodeWithoutChecks(code: Bytes)\n\t\t\tsetHeapPages(pages: u64)\n\t\t\tsetStorage(items: Vec<(Bytes,Bytes)>)\n\t\t`\n\t}, {\n\t\tname: \"TechnicalCommittee\", rpc_path: \"technicalCommittee\",\n\t\tfuncs: `\n\t\t\tclose(proposal_hash: H256, index: Compact<u32>, proposal_weight_bound: Compact<u64>, length_bound: Compact<u32>)\n\t\t\tdisapproveProposal(proposal_hash: H256)\n\t\t\texecute(proposal: Call, length_bound: Compact<u32>)\n\t\t\tpropose(threshold: Compact<u32>, proposal: Call, length_bound: Compact<u32>)\n\t\t\tsetMembers(new_members: Vec<AccountId32>, prime: Option<AccountId32>, old_count: u32)\n\t\t\tvote(proposal: H256, index: Compact<u32>, approve: bool)\n\t\t`\n\t}, {\n\t\tname: \"TechnicalMembership\", rpc_path: \"technicalMembership\",\n\t\tfuncs: `\n\t\t\taddMember(who: AccountId32)\n\t\t\tchangeKey(new: AccountId32)\n\t\t\tclearPrime()\n\t\t\tremoveMember(who: AccountId32)\n\t\t\tresetMembers(members: Vec<AccountId32>)\n\t\t\tsetPrime(who: AccountId32)\n\t\t\tswapMember(remove: AccountId32, add: AccountId32)\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tset(now: Compact<u64>)\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\tcloseTip(hash: H256)\n\t\t\treportAwesome(reason: Bytes, who: AccountId32)\n\t\t\tretractTip(hash: H256)\n\t\t\tslashTip(hash: H256)\n\t\t\ttip(hash: H256, tip_value: Compact<u128>)\n\t\t\ttipNew(reason: Bytes, who: AccountId32, tip_value: Compact<u128>)\n\t\t`\n\t}, {\n\t\tname: \"TransactionStorage\", rpc_path: \"transactionStorage\",\n\t\tfuncs: `\n\t\t\tcheckProof(proof: SpTransactionStorageProofTransactionStorageProof)\n\t\t\trenew(block: u32, index: u32)\n\t\t\tstore(data: Bytes)\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tapproveProposal(proposal_id: Compact<u32>)\n\t\t\tproposeSpend(value: Compact<u128>, beneficiary: MultiAddress)\n\t\t\trejectProposal(proposal_id: Compact<u32>)\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\tapproveTransfer(class: Compact<u32>, instance: Compact<u32>, delegate: MultiAddress)\n\t\t\tburn(class: Compact<u32>, instance: Compact<u32>, check_owner: Option<MultiAddress>)\n\t\t\tcancelApproval(class: Compact<u32>, instance: Compact<u32>, maybe_check_delegate: Option<MultiAddress>)\n\t\t\tclearAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes)\n\t\t\tclearClassMetadata(class: Compact<u32>)\n\t\t\tclearMetadata(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tcreate(class: Compact<u32>, admin: MultiAddress)\n\t\t\tdestroy(class: Compact<u32>, witness: PalletUniquesDestroyWitness)\n\t\t\tforceAssetStatus(class: Compact<u32>, owner: MultiAddress, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress, free_holding: bool, is_frozen: bool)\n\t\t\tforceCreate(class: Compact<u32>, owner: MultiAddress, free_holding: bool)\n\t\t\tfreeze(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tfreezeClass(class: Compact<u32>)\n\t\t\tmint(class: Compact<u32>, instance: Compact<u32>, owner: MultiAddress)\n\t\t\tredeposit(class: Compact<u32>, instances: Vec<u32>)\n\t\t\tsetAttribute(class: Compact<u32>, maybe_instance: Option<u32>, key: Bytes, value: Bytes)\n\t\t\tsetClassMetadata(class: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetMetadata(class: Compact<u32>, instance: Compact<u32>, data: Bytes, is_frozen: bool)\n\t\t\tsetTeam(class: Compact<u32>, issuer: MultiAddress, admin: MultiAddress, freezer: MultiAddress)\n\t\t\tthaw(class: Compact<u32>, instance: Compact<u32>)\n\t\t\tthawClass(class: Compact<u32>)\n\t\t\ttransfer(class: Compact<u32>, instance: Compact<u32>, dest: MultiAddress)\n\t\t\ttransferOwnership(class: Compact<u32>, owner: MultiAddress)\n\t\t`\n\t}, {\n\t\tname: \"Utility\", rpc_path: \"utility\",\n\t\tfuncs: `\n\t\t\tasDerivative(index: u16, call: Call)\n\t\t\tbatch(calls: Vec<Call>)\n\t\t\tbatchAll(calls: Vec<Call>)\n\t\t\tdispatchAs(as_origin: NodeRuntimeOriginCaller, call: Call)\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tforceVestedTransfer(source: MultiAddress, target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t\tmergeSchedules(schedule1_index: u32, schedule2_index: u32)\n\t\t\tvest()\n\t\t\tvestOther(target: MultiAddress)\n\t\t\tvestedTransfer(target: MultiAddress, schedule: PalletVestingVestingInfo)\n\t\t`\n\t}\n]);","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Keyring/Dummy\",\nclass DummyNode extends Blackprint.Node {\n\t// Input port\n\tstatic input = {\n\t\tKeyType: Blackprint.Port.Default(String, 'ed25519'),\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tAddress: String, // base58\n\t\tSeed: Uint8Array,\n\t\tSigner: Signer,\n\t\tPair: Object,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Dummy Key\";\n\t\tiface.description = \"Randomly generated wallet\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){ this.update() }\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\t// Generate new seed and put it to the output port\n\t\tOutput.Seed = polkadotUtilCrypto.randomAsU8a(32);\n\n\t\tlet keyring = new polkadotApi.Keyring({\n\t\t\ttype: Input.KeyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\t// Create keypair from seed and put it to the output port\n\t\tlet pair = Output.Pair = keyring.addFromSeed(Output.Seed);\n\n\t\t// Wrap the signer and put the public address to the output port\n\t\tOutput.Signer = new Signer(true, Output.Address, pair);\n\t\tOutput.Address = pair.address;\n\t}\n});","/**\n * import { Substrate_BlackprintNodeGenerator } from \"../RPC/generator.js\";\n */\n\n// This file may get changed on the future\n\n// https://polkadot.js.org/docs/substrate/storage\n// The parameters will be input port, and the returned data will be the output port\n// The function name will be the node's name (ex: Author HasKey)\n\nSubstrate_BlackprintNodeGenerator({\n\tnamespace: 'Storage',\n\tdescription: '[Experimental] Substrate Storage',\n\tapiPath: 'query',\n\tloose: true,\n\ttypeAsName: true,\n}, [\n\t{\n\t\tname: \"Assets\", rpc_path: \"assets\",\n\t\tfuncs: `\n\t\t\taccount(u32, AccountId32): Option<PalletAssetsAssetAccount>\n\t\t\tapprovals(u32, AccountId32, AccountId32): Option<PalletAssetsApproval>\n\t\t\tasset(u32): Option<PalletAssetsAssetDetails>\n\t\t\tmetadata(u32): PalletAssetsAssetMetadata\n\t\t`\n\t}, {\n\t\tname: \"AuthorityDiscovery\", rpc_path: \"authorityDiscovery\",\n\t\tfuncs: `\n\t\t\tkeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t\tnextKeys(): Vec<SpAuthorityDiscoveryAppPublic>\n\t\t`\n\t}, {\n\t\tname: \"Authorship\", rpc_path: \"authorship\",\n\t\tfuncs: `\n\t\t\tauthor(): Option<AccountId32>\n\t\t\tdidSetUncles(): bool\n\t\t\tuncles(): Vec<PalletAuthorshipUncleEntryItem>\n\t\t`\n\t}, {\n\t\tname: \"Babe\", rpc_path: \"babe\",\n\t\tfuncs: `\n\t\t\tauthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tauthorVrfRandomness(): Option<[u8;32]>\n\t\t\tcurrentSlot(): u64\n\t\t\tepochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tepochIndex(): u64\n\t\t\tepochStart(): (u32,u32)\n\t\t\tgenesisSlot(): u64\n\t\t\tinitialized(): Option<Option<[u8;32]>>\n\t\t\tlateness(): u32\n\t\t\tnextAuthorities(): Vec<(SpConsensusBabeAppPublic,u64)>\n\t\t\tnextEpochConfig(): Option<SpConsensusBabeBabeEpochConfiguration>\n\t\t\tnextRandomness(): [u8;32]\n\t\t\tpendingEpochConfigChange(): Option<SpConsensusBabeDigestsNextConfigDescriptor>\n\t\t\trandomness(): [u8;32]\n\t\t\tsegmentIndex(): u32\n\t\t\tunderConstruction(u32): Vec<[u8;32]>\n\t\t`\n\t}, {\n\t\tname: \"BagsList\", rpc_path: \"bagsList\",\n\t\tfuncs: `\n\t\t\tcounterForListNodes(): u32\n\t\t\tlistBags(u64): Option<PalletBagsListListBag>\n\t\t\tlistNodes(AccountId32): Option<PalletBagsListListNode>\n\t\t`\n\t}, {\n\t\tname: \"Balances\", rpc_path: \"balances\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32): PalletBalancesAccountData\n\t\t\tlocks(AccountId32): Vec<PalletBalancesBalanceLock>\n\t\t\treserves(AccountId32): Vec<PalletBalancesReserveData>\n\t\t\tstorageVersion(): PalletBalancesReleases\n\t\t\ttotalIssuance(): u128\n\t\t`\n\t}, {\n\t\tname: \"Bounties\", rpc_path: \"bounties\",\n\t\tfuncs: `\n\t\t\tbounties(u32): Option<PalletBountiesBounty>\n\t\t\tbountyApprovals(): Vec<u32>\n\t\t\tbountyCount(): u32\n\t\t\tbountyDescriptions(u32): Option<Bytes>\n\t\t`\n\t}, {\n\t\tname: \"ChildBounties\", rpc_path: \"childBounties\",\n\t\tfuncs: `\n\t\t\tchildBounties(u32, u32): Option<PalletChildBountiesChildBounty>\n\t\t\tchildBountyCount(): u32\n\t\t\tchildBountyDescriptions(u32): Option<Bytes>\n\t\t\tchildrenCuratorFees(u32): u128\n\t\t\tparentChildBounties(u32): u32\n\t\t`\n\t}, {\n\t\tname: \"Contracts\", rpc_path: \"contracts\",\n\t\tfuncs: `\n\t\t\taccountCounter(): u64\n\t\t\tcodeStorage(H256): Option<PalletContractsWasmPrefabWasmModule>\n\t\t\tcontractInfoOf(AccountId32): Option<PalletContractsStorageRawContractInfo>\n\t\t\tdeletionQueue(): Vec<PalletContractsStorageDeletedContract>\n\t\t\townerInfoOf(H256): Option<PalletContractsWasmOwnerInfo>\n\t\t\tpristineCode(H256): Option<Bytes>\n\t\t`\n\t}, {\n\t\tname: \"Council\", rpc_path: \"council\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t`\n\t}, {\n\t\tname: \"Democracy\", rpc_path: \"democracy\",\n\t\tfuncs: `\n\t\t\tblacklist(H256): Option<(u32,Vec<AccountId32>)>\n\t\t\tcancellations(H256): bool\n\t\t\tdepositOf(u32): Option<(Vec<AccountId32>,u128)>\n\t\t\tlastTabledWasExternal(): bool\n\t\t\tlocks(AccountId32): Option<u32>\n\t\t\tlowestUnbaked(): u32\n\t\t\tnextExternal(): Option<(H256,PalletDemocracyVoteThreshold)>\n\t\t\tpreimages(H256): Option<PalletDemocracyPreimageStatus>\n\t\t\tpublicPropCount(): u32\n\t\t\tpublicProps(): Vec<(u32,H256,AccountId32)>\n\t\t\treferendumCount(): u32\n\t\t\treferendumInfoOf(u32): Option<PalletDemocracyReferendumInfo>\n\t\t\tstorageVersion(): Option<PalletDemocracyReleases>\n\t\t\tvotingOf(AccountId32): PalletDemocracyVoteVoting\n\t\t`\n\t}, {\n\t\tname: \"ElectionProviderMultiPhase\", rpc_path: \"electionProviderMultiPhase\",\n\t\tfuncs: `\n\t\t\tcurrentPhase(): PalletElectionProviderMultiPhasePhase\n\t\t\tdesiredTargets(): Option<u32>\n\t\t\tminimumUntrustedScore(): Option<[u128;3]>\n\t\t\tqueuedSolution(): Option<PalletElectionProviderMultiPhaseReadySolution>\n\t\t\tround(): u32\n\t\t\tsignedSubmissionIndices(): BTreeMap<[u128;3], u32>\n\t\t\tsignedSubmissionNextIndex(): u32\n\t\t\tsignedSubmissionsMap(u32): Option<PalletElectionProviderMultiPhaseSignedSignedSubmission>\n\t\t\tsnapshot(): Option<PalletElectionProviderMultiPhaseRoundSnapshot>\n\t\t\tsnapshotMetadata(): Option<PalletElectionProviderMultiPhaseSolutionOrSnapshotSize>\n\t\t`\n\t}, {\n\t\tname: \"Elections\", rpc_path: \"elections\",\n\t\tfuncs: `\n\t\t\tcandidates(): Vec<(AccountId32,u128)>\n\t\t\telectionRounds(): u32\n\t\t\tmembers(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\trunnersUp(): Vec<PalletElectionsPhragmenSeatHolder>\n\t\t\tvoting(AccountId32): PalletElectionsPhragmenVoter\n\t\t`\n\t}, {\n\t\tname: \"Gilt\", rpc_path: \"gilt\",\n\t\tfuncs: `\n\t\t\tactive(u32): Option<PalletGiltActiveGilt>\n\t\t\tactiveTotal(): PalletGiltActiveGiltsTotal\n\t\t\tqueues(u32): Vec<PalletGiltGiltBid>\n\t\t\tqueueTotals(): Vec<(u32,u128)>\n\t\t`\n\t}, {\n\t\tname: \"Grandpa\", rpc_path: \"grandpa\",\n\t\tfuncs: `\n\t\t\tcurrentSetId(): u64\n\t\t\tnextForced(): Option<u32>\n\t\t\tpendingChange(): Option<PalletGrandpaStoredPendingChange>\n\t\t\tsetIdSession(u64): Option<u32>\n\t\t\tstalled(): Option<(u32,u32)>\n\t\t\tstate(): PalletGrandpaStoredState\n\t\t`\n\t}, {\n\t\tname: \"Identity\", rpc_path: \"identity\",\n\t\tfuncs: `\n\t\t\tidentityOf(AccountId32): Option<PalletIdentityRegistration>\n\t\t\tregistrars(): Vec<Option<PalletIdentityRegistrarInfo>>\n\t\t\tsubsOf(AccountId32): (u128,Vec<AccountId32>)\n\t\t\tsuperOf(AccountId32): Option<(AccountId32,Data)>\n\t\t`\n\t}, {\n\t\tname: \"ImOnline\", rpc_path: \"imOnline\",\n\t\tfuncs: `\n\t\t\tauthoredBlocks(u32, AccountId32): u32\n\t\t\theartbeatAfter(): u32\n\t\t\tkeys(): Vec<PalletImOnlineSr25519AppSr25519Public>\n\t\t\treceivedHeartbeats(u32, u32): Option<WrapperOpaque<PalletImOnlineBoundedOpaqueNetworkState>>\n\t\t`\n\t}, {\n\t\tname: \"Indices\", rpc_path: \"indices\",\n\t\tfuncs: `\n\t\t\taccounts(u32): Option<(AccountId32,u128,bool)>\n\t\t`\n\t}, {\n\t\tname: \"Lottery\", rpc_path: \"lottery\",\n\t\tfuncs: `\n\t\t\tcallIndices(): Vec<(u8,u8)>\n\t\t\tlottery(): Option<PalletLotteryLotteryConfig>\n\t\t\tlotteryIndex(): u32\n\t\t\tparticipants(AccountId32): (u32,Vec<(u8,u8)>)\n\t\t\ttickets(u32): Option<AccountId32>\n\t\t\tticketsCount(): u32\n\t\t`\n\t}, {\n\t\tname: \"Mmr\", rpc_path: \"mmr\",\n\t\tfuncs: `\n\t\t\tnodes(u64): Option<H256>\n\t\t\tnumberOfLeaves(): u64\n\t\t\trootHash(): H256\n\t\t`\n\t}, {\n\t\tname: \"Multisig\", rpc_path: \"multisig\",\n\t\tfuncs: `\n\t\t\tcalls([u8;32]): Option<(WrapperKeepOpaque<Call>,AccountId32,u128)>\n\t\t\tmultisigs(AccountId32, [u8;32]): Option<PalletMultisigMultisig>\n\t\t`\n\t}, {\n\t\tname: \"Offences\", rpc_path: \"offences\",\n\t\tfuncs: `\n\t\t\tconcurrentReportsIndex([u8;16], Bytes): Vec<H256>\n\t\t\treports(H256): Option<SpStakingOffenceOffenceDetails>\n\t\t\treportsByKindIndex([u8;16]): Bytes\n\t\t`\n\t}, {\n\t\tname: \"Preimage\", rpc_path: \"preimage\",\n\t\tfuncs: `\n\t\t\tpreimageFor(H256): Option<Bytes>\n\t\t\tstatusFor(H256): Option<PalletPreimageRequestStatus>\n\t\t`\n\t}, {\n\t\tname: \"Proxy\", rpc_path: \"proxy\",\n\t\tfuncs: `\n\t\t\tannouncements(AccountId32): (Vec<PalletProxyAnnouncement>,u128)\n\t\t\tproxies(AccountId32): (Vec<PalletProxyProxyDefinition>,u128)\n\t\t`\n\t}, {\n\t\tname: \"RandomnessCollectiveFlip\", rpc_path: \"randomnessCollectiveFlip\",\n\t\tfuncs: `\n\t\t\trandomMaterial(): Vec<H256>\n\t\t`\n\t}, {\n\t\tname: \"Recovery\", rpc_path: \"recovery\",\n\t\tfuncs: `\n\t\t\tactiveRecoveries(AccountId32, AccountId32): Option<PalletRecoveryActiveRecovery>\n\t\t\tproxy(AccountId32): Option<AccountId32>\n\t\t\trecoverable(AccountId32): Option<PalletRecoveryRecoveryConfig>\n\t\t`\n\t}, {\n\t\tname: \"Scheduler\", rpc_path: \"scheduler\",\n\t\tfuncs: `\n\t\t\tagenda(u32): Vec<Option<PalletSchedulerScheduledV3>>\n\t\t\tlookup(Bytes): Option<(u32,u32)>\n\t\t`\n\t}, {\n\t\tname: \"Session\", rpc_path: \"session\",\n\t\tfuncs: `\n\t\t\tcurrentIndex(): u32\n\t\t\tdisabledValidators(): Vec<u32>\n\t\t\tkeyOwner((SpCoreCryptoKeyTypeId,Bytes)): Option<AccountId32>\n\t\t\tnextKeys(AccountId32): Option<NodeRuntimeSessionKeys>\n\t\t\tqueuedChanged(): bool\n\t\t\tqueuedKeys(): Vec<(AccountId32,NodeRuntimeSessionKeys)>\n\t\t\tvalidators(): Vec<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"Society\", rpc_path: \"society\",\n\t\tfuncs: `\n\t\t\tbids(): Vec<PalletSocietyBid>\n\t\t\tcandidates(): Vec<PalletSocietyBid>\n\t\t\tdefender(): Option<AccountId32>\n\t\t\tdefenderVotes(AccountId32): Option<PalletSocietyVote>\n\t\t\tfounder(): Option<AccountId32>\n\t\t\thead(): Option<AccountId32>\n\t\t\tmaxMembers(): u32\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tpayouts(AccountId32): Vec<(u32,u128)>\n\t\t\tpot(): u128\n\t\t\trules(): Option<H256>\n\t\t\tstrikes(AccountId32): u32\n\t\t\tsuspendedCandidates(AccountId32): Option<(u128,PalletSocietyBidKind)>\n\t\t\tsuspendedMembers(AccountId32): bool\n\t\t\tvotes(AccountId32, AccountId32): Option<PalletSocietyVote>\n\t\t\tvouching(AccountId32): Option<PalletSocietyVouchingStatus>\n\t\t`\n\t}, {\n\t\tname: \"Staking\", rpc_path: \"staking\",\n\t\tfuncs: `\n\t\t\tactiveEra(): Option<PalletStakingActiveEraInfo>\n\t\t\tbonded(AccountId32): Option<AccountId32>\n\t\t\tbondedEras(): Vec<(u32,u32)>\n\t\t\tcanceledSlashPayout(): u128\n\t\t\tchillThreshold(): Option<Percent>\n\t\t\tcounterForNominators(): u32\n\t\t\tcounterForValidators(): u32\n\t\t\tcurrentEra(): Option<u32>\n\t\t\tcurrentPlannedSession(): u32\n\t\t\tearliestUnappliedSlash(): Option<u32>\n\t\t\terasRewardPoints(u32): PalletStakingEraRewardPoints\n\t\t\terasStakers(u32, AccountId32): PalletStakingExposure\n\t\t\terasStakersClipped(u32, AccountId32): PalletStakingExposure\n\t\t\terasStartSessionIndex(u32): Option<u32>\n\t\t\terasTotalStake(u32): u128\n\t\t\terasValidatorPrefs(u32, AccountId32): PalletStakingValidatorPrefs\n\t\t\terasValidatorReward(u32): Option<u128>\n\t\t\tforceEra(): PalletStakingForcing\n\t\t\thistoryDepth(): u32\n\t\t\tinvulnerables(): Vec<AccountId32>\n\t\t\tledger(AccountId32): Option<PalletStakingStakingLedger>\n\t\t\tmaxNominatorsCount(): Option<u32>\n\t\t\tmaxValidatorsCount(): Option<u32>\n\t\t\tminCommission(): Perbill\n\t\t\tminimumValidatorCount(): u32\n\t\t\tminNominatorBond(): u128\n\t\t\tminValidatorBond(): u128\n\t\t\tnominators(AccountId32): Option<PalletStakingNominations>\n\t\t\tnominatorSlashInEra(u32, AccountId32): Option<u128>\n\t\t\toffendingValidators(): Vec<(u32,bool)>\n\t\t\tpayee(AccountId32): PalletStakingRewardDestination\n\t\t\tslashingSpans(AccountId32): Option<PalletStakingSlashingSlashingSpans>\n\t\t\tslashRewardFraction(): Perbill\n\t\t\tspanSlash((AccountId32,u32)): PalletStakingSlashingSpanRecord\n\t\t\tstorageVersion(): PalletStakingReleases\n\t\t\tunappliedSlashes(u32): Vec<PalletStakingUnappliedSlash>\n\t\t\tvalidatorCount(): u32\n\t\t\tvalidators(AccountId32): PalletStakingValidatorPrefs\n\t\t\tvalidatorSlashInEra(u32, AccountId32): Option<(Perbill,u128)>\n\t\t`\n\t}, {\n\t\tname: \"Substrate\", rpc_path: \"substrate\",\n\t\tfuncs: `\n\t\t\tchangesTrieConfig(): u32\n\t\t\tchildStorageKeyPrefix(): u32\n\t\t\tcode(): Bytes\n\t\t\textrinsicIndex(): u32\n\t\t\theapPages(): u64\n\t\t`\n\t}, {\n\t\tname: \"Sudo\", rpc_path: \"sudo\",\n\t\tfuncs: `\n\t\t\tkey(): Option<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"System\", rpc_path: \"system\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32): FrameSystemAccountInfo\n\t\t\tallExtrinsicsLen(): Option<u32>\n\t\t\tblockHash(u32): H256\n\t\t\tblockWeight(): FrameSupportWeightsPerDispatchClassU64\n\t\t\tdigest(): SpRuntimeDigest\n\t\t\teventCount(): u32\n\t\t\tevents(): Vec<FrameSystemEventRecord>\n\t\t\teventTopics(H256): Vec<(u32,u32)>\n\t\t\texecutionPhase(): Option<FrameSystemPhase>\n\t\t\textrinsicCount(): Option<u32>\n\t\t\textrinsicData(u32): Bytes\n\t\t\tlastRuntimeUpgrade(): Option<FrameSystemLastRuntimeUpgradeInfo>\n\t\t\tnumber(): u32\n\t\t\tparentHash(): H256\n\t\t\tupgradedToTripleRefCount(): bool\n\t\t\tupgradedToU32RefCount(): bool\n\t\t`\n\t}, {\n\t\tname: \"TechnicalCommittee\", rpc_path: \"technicalCommittee\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t\tproposalCount(): u32\n\t\t\tproposalOf(H256): Option<Call>\n\t\t\tproposals(): Vec<H256>\n\t\t\tvoting(H256): Option<PalletCollectiveVotes>\n\t\t`\n\t}, {\n\t\tname: \"TechnicalMembership\", rpc_path: \"technicalMembership\",\n\t\tfuncs: `\n\t\t\tmembers(): Vec<AccountId32>\n\t\t\tprime(): Option<AccountId32>\n\t\t`\n\t}, {\n\t\tname: \"Timestamp\", rpc_path: \"timestamp\",\n\t\tfuncs: `\n\t\t\tdidUpdate(): bool\n\t\t\tnow(): u64\n\t\t`\n\t}, {\n\t\tname: \"Tips\", rpc_path: \"tips\",\n\t\tfuncs: `\n\t\t\treasons(H256): Option<Bytes>\n\t\t\ttips(H256): Option<PalletTipsOpenTip>\n\t\t`\n\t}, {\n\t\tname: \"TransactionPayment\", rpc_path: \"transactionPayment\",\n\t\tfuncs: `\n\t\t\tnextFeeMultiplier(): u128\n\t\t\tstorageVersion(): PalletTransactionPaymentReleases\n\t\t`\n\t}, {\n\t\tname: \"TransactionStorage\", rpc_path: \"transactionStorage\",\n\t\tfuncs: `\n\t\t\tblockTransactions(): Vec<PalletTransactionStorageTransactionInfo>\n\t\t\tbyteFee(): Option<u128>\n\t\t\tchunkCount(u32): u32\n\t\t\tentryFee(): Option<u128>\n\t\t\tmaxBlockTransactions(): u32\n\t\t\tmaxTransactionSize(): u32\n\t\t\tproofChecked(): bool\n\t\t\tstoragePeriod(): u32\n\t\t\ttransactions(u32): Option<Vec<PalletTransactionStorageTransactionInfo>>\n\t\t`\n\t}, {\n\t\tname: \"Treasury\", rpc_path: \"treasury\",\n\t\tfuncs: `\n\t\t\tapprovals(): Vec<u32>\n\t\t\tproposalCount(): u32\n\t\t\tproposals(u32): Option<PalletTreasuryProposal>\n\t\t`\n\t}, {\n\t\tname: \"Uniques\", rpc_path: \"uniques\",\n\t\tfuncs: `\n\t\t\taccount(AccountId32, u32, u32): Option<Null>\n\t\t\tasset(u32, u32): Option<PalletUniquesInstanceDetails>\n\t\t\tattribute(u32, Option<u32>, Bytes): Option<(Bytes,u128)>\n\t\t\tclass(u32): Option<PalletUniquesClassDetails>\n\t\t\tclassAccount(AccountId32, u32): Option<Null>\n\t\t\tclassMetadataOf(u32): Option<PalletUniquesClassMetadata>\n\t\t\tinstanceMetadataOf(u32, u32): Option<PalletUniquesInstanceMetadata>\n\t\t`\n\t}, {\n\t\tname: \"Vesting\", rpc_path: \"vesting\",\n\t\tfuncs: `\n\t\t\tstorageVersion(): PalletVestingReleases\n\t\t\tvesting(AccountId32): Option<Vec<PalletVestingVestingInfo>>\n\t\t`\n\t}\n]);","Blackprint.registerNode(\"Polkadot.js/Transaction/DryRun\",\nclass TransferNode extends Blackprint.Node {\n\tstatic input = {\n\t\tProvider: Blackprint.Port.Union([polkadotApi.WsProvider, polkadotApi.HttpProvider]),\n\t\tSigner: Signer,\n\t\tTxn: Transaction,\n\t};\n\n\tstatic output = {\n\t\tStatus: Object\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Dry Run Transaction\";\n\t\tiface.description = \"Try a transaction but not actually execute it\";\n\t}\n\n\timported(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet toast = new NodeToast(this.iface);\n\n\t\tfunction onStatus(ev){\n\t\t\tOutput.Status = ev;\n\t\t}\n\n\t\tasync function onChanged(){\n\t\t\tif(Input.Provider === null) return toast.warn(\"Provider is required\");\n\t\t\tif(Input.Signer === null) return toast.warn(\"Signer is required\");\n\t\t\tif(Input.Txn === null) return toast.warn(\"Txn is required\");\n\t\t\ttoast.clear();\n\n\t\t\tlet ref = Input.Signer;\n\t\t\tlet txn = Input.Txn.txn;\n\n\t\t\ttry{\n\t\t\t\tif(ref.isPair)\n\t\t\t\t\tawait txn.dryRun(ref.signer, onStatus);\n\t\t\t\telse await txn.dryRun(ref.address, {signer: ref.signer}, onStatus);\n\t\t\t} catch(e) {\n\t\t\t\tconsole.log(toast, e);\n\t\t\t\ttoast.error(e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\tthis.iface.on('port.value', Context.EventSlot, onChanged);\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, function({ port }){\n\t\t\tif(port.source === 'input') onChanged();\n\t\t});\n\t}\n});","Blackprint.registerNode(\"Polkadot.js/Transaction/PaymentInfo\",\nclass PaymentInfoNode extends Blackprint.Node {\n\tstatic input = {\n\t\tProvider: Blackprint.Port.Union([polkadotApi.WsProvider, polkadotApi.HttpProvider]),\n\t\tSigner: Signer,\n\t\tTxn: Transaction,\n\t};\n\n\tstatic output = {\n\t\tInfo: Object\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Txn Payment Info\";\n\t}\n\n\timported(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet toast = new NodeToast(this.iface);\n\n\t\tasync function onChanged(){\n\t\t\tif(Input.Provider === null) return toast.warn(\"Provider is required\");\n\t\t\tif(Input.Signer === null) return toast.warn(\"Signer is required\");\n\t\t\tif(Input.Txn === null) return toast.warn(\"Txn is required\");\n\t\t\ttoast.clear();\n\n\t\t\tlet ref = Input.Signer;\n\t\t\tlet txn = Input.Txn.txn;\n\n\t\t\tlet info;\n\t\t\ttry{\n\t\t\t\tif(ref.isPair)\n\t\t\t\t\tinfo = await txn.paymentInfo(ref.signer);\n\t\t\t\telse info = await txn.paymentInfo(ref.address, {signer: ref.signer});\n\t\t\t} catch(e) {\n\t\t\t\ttoast.error(e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tOutput.Info = info;\n\t\t}\n\n\t\tthis.iface.on('port.value', Context.EventSlot, onChanged);\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, function({ port }){\n\t\t\tif(port.source === 'input') onChanged();\n\t\t});\n\t}\n});","Blackprint.registerNode(\"Polkadot.js/Transaction/Send\",\nclass TransferNode extends Blackprint.Node {\n\tstatic input = {\n\t\tSubmit: Blackprint.Port.Trigger(function(){\n\t\t\tthis.submit(true);\n\t\t}),\n\t\tProvider: Blackprint.Port.Union([polkadotApi.WsProvider, polkadotApi.HttpProvider]),\n\t\tSigner: Signer,\n\t\tTxn: Transaction,\n\t};\n\n\tstatic output = {\n\t\tStatus: Object\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Send Transaction\";\n\t}\n\n\timported(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet toast = new NodeToast(this.iface);\n\n\t\tfunction onStatus(ev){\n\t\t\tOutput.Status = ev;\n\t\t}\n\n\t\tlet onChanged = this.submit = async function(isSubmit){\n\t\t\tif(Input.Provider === null) return toast.warn(\"Provider is required\");\n\t\t\tif(Input.Signer === null) return toast.warn(\"Signer is required\");\n\t\t\tif(Input.Txn === null) return toast.warn(\"Txn is required\");\n\t\t\ttoast.clear();\n\n\t\t\tif(isSubmit !== true) return;\n\n\t\t\tlet ref = Input.Signer;\n\t\t\tlet txn = Input.Txn.txn;\n\n\t\t\ttry{\n\t\t\t\tif(ref.isPair)\n\t\t\t\t\tawait txn.signAndSend(ref.signer, onStatus);\n\t\t\t\telse await txn.signAndSend(ref.address, {signer: ref.signer}, onStatus);\n\t\t\t} catch(e) {\n\t\t\t\ttoast.error(e.message);\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\tthis.iface.on('port.value', Context.EventSlot, onChanged);\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, function({ port }){\n\t\t\tif(port.source === 'input') onChanged();\n\t\t});\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotKeyring } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Convert/Address To/Address\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic output = {Address: String};\n\tstatic input = {\n\t\tAddress: String,\n\t\tChainId: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Address to Address\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ()=> this.update());\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Address = null;\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Address) return this._fail('Address is required');\n\t\tif(!Input.ChainId) return this._fail('ChainId is required');\n\n\t\tthis._toast.clear();\n\t\tOutput.Address = polkadotKeyring.encodeAddress(Input.Address, Input.ChainId);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotKeyring } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Convert/Address To/Uint8Array\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic output = { Bytes: Uint8Array };\n\tstatic input = { Address: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Address to Address\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ()=> this.update());\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Bytes = null;\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Address) return this._fail('Address is required');\n\n\t\tthis._toast.clear();\n\t\tOutput.Bytes = polkadotKeyring.decodeAddress(Input.Address);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotUtil } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Convert/String To/Uint8Array\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic output = {Out: Uint8Array};\n\tstatic input = {In: String};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"String to Uint8Array\";\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.In.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Out = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tOutput.Out = polkadotUtil.stringToU8a(Input.In);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * { polkadotUtil } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Convert/Uint8Array To/String\",\nclass RandomSeedNode extends Blackprint.Node {\n\tstatic output = {Out: String};\n\tstatic input = {In: Uint8Array};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface();\n\t\tiface.title = \"Uint8Array to String\";\n\t}\n\n\t// Event listener can be registered after init\n\tinit(){\n\t\t// Clear the output port when the input cable was disconnected\n\t\tthis.iface.input.In.on('disconnect', Context.EventSlot, ()=> {\n\t\t\tthis.output.Out = null;\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tOutput.Out = polkadotUtil.u8aToString(Input.In);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil, polkadotKeyring } = window\n */\n\n// This will be used for DecryptNode and EncryptNode\nclass CrypterNode extends Blackprint.Node {\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tiface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t_fail(msg){\n\t\tthis.output.Bytes = null; // Clear the output data if something was fail/error\n\t\tthis._toast.warn(msg);\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Keypair)\n\t\t\treturn this._fail(\"Keypair is required\");\n\n\t\tif(!Input.Data)\n\t\t\treturn this._fail(\"Data is required\");\n\n\t\t// Remove any node toast\n\t\ttoast.clear();\n\n\t\t// If the Data is an string, let's convert it to Uint8Array\n\t\tlet data = Input.Data;\n\t\tif(data.constructor === String)\n\t\t\tdata = polkadotUtil.stringToU8a(data);\n\n\t\treturn {keypair: Input.Keypair, data};\n\t}\n}\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Data/Keyring/Decrypt\",\nclass DecryptNode extends CrypterNode {\n\t// Input port\n\tstatic input = {\n\t\tKeypair: Object,\n\t\tAuthor: Blackprint.Port.Union([String, Uint8Array]), // base58, hex, public key's bytes\n\t\tData: Blackprint.Port.Union([String, Uint8Array]), // text, bytes\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tBytes: Uint8Array\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\t\tthis.iface.title = \"Decrypt Data\";\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Author)\n\t\t\treturn this._fail(\"Author address is required\");\n\n\t\tlet temp = super.update();\n\t\tif(!temp) return;\n\n\t\tlet { keypair, data } = temp;\n\t\tlet author = Input.Author;\n\n\t\ttry {\n\t\t\t// Convert address to Uint8Array\n\t\t\tif(author.constructor === String)\n\t\t\t\tauthor = polkadotKeyring.decodeAddress(author);\n\n\t\t\t// Decrypt the data\n\t\t\tvar decrypted = keypair.decryptMessage(data, author);\n\t\t} catch(e) {\n\t\t\tthis.output.Bytes = null; // Clear the output data\n\t\t\tthis._toast.error(e.message);\n\t\t\tthrow e;\n\t\t}\n\n\t\tif(!decrypted){\n\t\t\tthis.output.Bytes = null; // Clear the output data\n\t\t\tthis._toast.error(\"Unable to decrypt data\");\n\t\t\treturn;\n\t\t}\n\n\t\t// Put it on output port\n\t\tOutput.Bytes = decrypted;\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * import { CrypterNode } from \"./Decrypt.js\";\n * { polkadotUtil, polkadotKeyring } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Data/Keyring/Encrypt\",\nclass EncryptNode extends CrypterNode {\n\t// Input port\n\tstatic input = {\n\t\tKeypair: Object,\n\t\tTarget: Blackprint.Port.Union([String, Uint8Array]), // base58, hex, public key's bytes\n\t\tData: Blackprint.Port.Union([String, Uint8Array]), // text, bytes\n\t};\n\n\t// Output port\n\tstatic output = {\n\t\tBytes: Uint8Array\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\t\tthis.iface.title = \"Encrypt Data\";\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\n\t\tif(!Input.Target)\n\t\t\treturn this._fail(\"Target address is required\");\n\n\t\tlet temp = super.update();\n\t\tif(!temp) return;\n\n\t\tlet { keypair, data } = temp;\n\t\tlet target = Input.Target;\n\n\t\ttry {\n\t\t\t// Convert address to Uint8Array\n\t\t\tif(target.constructor === String)\n\t\t\t\ttarget = polkadotKeyring.decodeAddress(target);\n\n\t\t\t// Encrypt the data\n\t\t\tvar encrypt = keypair.encryptMessage(data, target);\n\t\t} catch(e) {\n\t\t\tthis.output.Bytes = null; // Clear the output data\n\t\t\tthis._toast.error(e.message);\n\t\t\tthrow e;\n\t\t}\n\n\t\t// Put it on output port\n\t\tOutput.Bytes = encrypt;\n\t}\n});","Blackprint.registerNode(\"Polkadot.js/Events/Account/Balance\",\nclass AccountBalanceNode extends Blackprint.Node {\n\tstatic input = {\n\t\tAPI: polkadotApi.ApiPromise,\n\t\tAddress: String,\n\t};\n\n\tstatic output = {\n\t\tValue: Number,\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface('BPIC/Polkadot.js/Events/Account/Balance');\n\t\tiface.title = \"Account Balance Event\";\n\t\tiface.description = \"Listen for balance changes\";\n\t}\n});\n\nBlackprint.registerInterface('BPIC/Polkadot.js/Events/Account/Balance',\nContext.IFace.EventsAccountBalance = class AccountBalanceIFace extends Blackprint.Interface {\n\tconstructor(node){\n\t\tsuper(node);\n\n\t\tthis.unsubscribe = false;\n\t}\n\n\timported(){\n\t\tlet {Input, Output, IInput, IOutput} = this.ref; // Shortcut\n\t\tlet iface = this;\n\t\tlet toast = new NodeToast(this);\n\n\t\tIInput.API.on('value', Context.EventSlot, async function(){\n\t\t\tif(iface.unsubscribe) iface.unsubscribe();\n\n\t\t\tlet api = Input.API;\n\t\t\tif(!api) return;\n\n\t\t\tiface.unsubscribe = await api.query.system.account(Input.Address, function(ev){\n\t\t\t\tconsole.log(ev);\n\t\t\t\t// Output.Value = ev.number.toNumber();\n\t\t\t});\n\t\t})\n\t\t.on('disconnect', Context.EventSlot, function(){\n\t\t\tif(iface.unsubscribe) iface.unsubscribe();\n\t\t});\n\t}\n\n\tdestroy(){\n\t\tif(this.unsubscribe) this.unsubscribe();\n\t}\n});","/**\n * import { Context, Signer } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotExtensionDapp } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Extension/Get/Signer\",\nclass SignerNode extends Blackprint.Node {\n\t// Node's input/output port\n\tstatic input = { Address: String };\n\tstatic output = { Signer: Signer };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Signer\";\n\t\tiface.description = \"Sign data with browser extension\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tasync update(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(!Input.Address)\n\t\t\treturn toast.warn(\"Address is required\");\n\n\t\t// Wait for permission\n\t\tif(extensionEnabled !== true){\n\t\t\ttoast.warn(\"No access to browser extension\");\n\t\t\tawait extensionEnabled;\n\t\t}\n\n\t\t// Clear any toast if exist\n\t\ttoast.clear();\n\n\t\t// Get the Web3 signer object\n\t\ttry{\n\t\t\tvar obj = await polkadotExtensionDapp.web3FromAddress(Input.Address);\n\t\t} catch(e) {\n\t\t\treturn toast.warn(e.message);\n\t\t}\n\n\t\t// Wrap it as Signer type and set it as output\n\t\tOutput.Signer = new Signer(false, Input.Address, obj.signer);\n\t}\n});","/**\n * import { Context, Signer, internalKeyring } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi, polkadotUtilCrypto } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Keypair\",\nclass KeypairNode extends Blackprint.Node {\n\t// Node's input/output port\n\tstatic output = {\n\t\tKeypair: Object,\n\t\tAddress: String,\n\t\t// PublicKey: Uint8Array,\n\t\tSigner: Signer,\n\t};\n\n\tstatic input = {\n\t\tKeyring: Blackprint.Port.Default(polkadotApi.Keyring, internalKeyring),\n\t\tSeed: Blackprint.Port.Union([String, Uint8Array]), // hex, or 32 bytes U8A\n\t\tMnemonic: String, // 12 or 24 words\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Create Keypair\";\n\t\tiface.description = \"Using internal keyring\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tthis.iface.on('cable.disconnect', Context.EventSlot, ({ port })=> {\n\t\t\tif(port.source === 'input') this.update();\n\t\t});\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output, IInput } = this.ref; // Shortcut\n\t\tlet toast = this._toast;\n\n\t\tif(Input.Keyring === internalKeyring)\n\t\t\tthis.iface.description = \"Using internal keyring: \"+Input.Keyring.type;\n\t\telse this.iface.description = \"Using connected keyring: \"+Input.Keyring.type;\n\n\t\t// Obtain last keyring and save the new keyring to this node object\n\t\tlet oldKeyring = this._keyring;\n\t\tthis._keyring = Input.Keyring;\n\n\t\t// If the input port was changed, remove keypair from the old keyring\n\t\tif(Output.Keypair != null){\n\t\t\toldKeyring.removePair(Output.Keypair.address);\n\t\t\tOutput.Keypair = null;\n\t\t}\n\n\t\tlet { Keyring, Seed, Mnemonic } = Input;\n\t\tif(!!Mnemonic) {\n\t\t\t// Disconnect cable from Seed port if exist\n\t\t\tIInput.Seed.disconnectAll();\n\n\t\t\tif(!polkadotUtilCrypto.mnemonicValidate(Mnemonic))\n\t\t\t\treturn toast.warn(\"Invalid mnemonic, it must be 12 or 24 words\");\n\n\t\t\tOutput.Keypair = Keyring.addFromMnemonic(Mnemonic);\n\t\t}\n\t\telse if(Seed != null) {\n\t\t\t// Disconnect cable from Mnemonic port if exist\n\t\t\tIInput.Mnemonic.disconnectAll();\n\n\t\t\t// It must be 32 bytes\n\t\t\tif(Seed.byteLength !== 32)\n\t\t\t\treturn toast.warn(\"Seed must be 32 bytes\");\n\n\t\t\tOutput.Keypair = Keyring.addFromSeed(Mnemonic);\n\t\t}\n\t\telse {\n\t\t\tOutput.Keypair = null;\n\t\t\tOutput.Address = null;\n\t\t\tOutput.Signer = null;\n\t\t\t// Output.PublicKey = null;\n\t\t\treturn toast.warn(\"Seed or Mnemonic is required\");\n\t\t}\n\n\t\ttoast.clear();\n\t\tlet pair = Output.Keypair;\n\n\t\t// Wrap the signer and put it to the output port\n\t\tOutput.Signer = new Signer(true, pair.address, pair);\n\t\tOutput.Address = pair.address;\n\t\t// Output.PublicKey = pair.publicKey;\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotApi } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Keyring\",\nclass KeyringNode extends Blackprint.Node {\n\t// Output port\n\tstatic output = {\n\t\tKeyring: polkadotApi.Keyring\n\t};\n\n\t// Input port\n\tstatic input = {\n\t\tKeyType: Blackprint.Port.Default(String, 'ed25519'),\n\t};\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Keyring\";\n\t\tiface.description = \"Collection of keys\";\n\n\t\tthis._toast = new NodeToast(this.iface);\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\t// We will use event listener instead 'update()'\n\timported(){\n\t\tlet { Input, Output, IInput } = this.ref; // Shortcut\n\n\t\t// Create initial Keyring\n\t\tthis.currentKeyType = Input.KeyType;\n\t\tOutput.Keyring = new polkadotApi.Keyring({\n\t\t\ttype: Input.KeyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\t// Manually call 'update' when any cable from input port was disconnected\n\t\tIInput.KeyType.on('disconnect', Context.EventSlot, () => this.update());\n\t}\n\n\t// This will be called by the engine if the input port have a new value\n\tupdate(){\n\t\tlet { Input, Output } = this.ref; // Shortcut\n\t\tlet keyType = Input.KeyType.toLowerCase();\n\t\tlet toast = this._toast;\n\n\t\t// Update only if keytype was changed (ed25519 <~> sr25519)\n\t\tif(this.currentKeyType === keyType)\n\t\t\treturn toast.clear();\n\n\t\tif(keyType !== 'ed25519'\n\t\t   && keyType !== 'sr25519'\n\t\t   && keyType !== 'ethereum'\n\t\t   && keyType !== 'ecdsa'){\n\t\t\treturn toast.warn(\"Invalid KeyType, it must be ed25519, sr25519, ethereum, or ecdsa\");\n\t\t}\n\n\t\t// Recreate Keyring\n\t\tOutput.Keyring = new polkadotApi.Keyring({\n\t\t\ttype: keyType, // default to ed25519\n\t\t\tss58Format: 0, // To use different format, Polkadot.js/Convert/Address To/Address is recommended\n\t\t});\n\n\t\tthis.currentKeyType = keyType;\n\t\ttoast.clear();\n\t}\n});","/**\n * { polkadotUtilCrypto } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Mnemonic\",\nclass RandomSeedNode extends Blackprint.Node {\n\t// Input port\n\t// static input = { Length: Blackprint.Port.Default(Number, 12) };\n\n\t// Output port\n\tstatic output = { Text: String };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Create Mnemonic\";\n\t\tiface.description = \"Generate random mnemonic\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){\n\t\t// this.update();\n\t\tthis.output.Text = polkadotUtilCrypto.mnemonicGenerate(12);\n\t}\n});","/**\n * import { Context } from \"../_init.js\";\n * import { NodeToast } from \"../utils/NodeToast.js\";\n * { polkadotUtil, polkadotUtilCrypto } = window\n */\n\n\n// Register Blackprint Node\nBlackprint.registerNode(\"Polkadot.js/Keyring/Create/Seed\",\nclass RandomSeedNode extends Blackprint.Node {\n\t// Output port\n\tstatic output = { Seed: Uint8Array };\n\n\tconstructor(instance){\n\t\tsuper(instance);\n\n\t\tlet iface = this.setInterface(); // use empty interface\n\t\tiface.title = \"Random Seed\";\n\t\tiface.description = \"Generate random seed\";\n\t}\n\n\t// This will be called by the engine once the node has been loaded\n\timported(){\n\t\tthis.output.Seed = polkadotUtilCrypto.randomAsU8a(32);\n\t}\n});"]}